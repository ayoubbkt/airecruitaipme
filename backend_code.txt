
=== Contenu de backend\api-gateway\src\main\java\com\recruitpme\apigateway\ApiGatewayApplication.java ===
// ApiGatewayApplication.java
package com.recruitpme.apigateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class ApiGatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(ApiGatewayApplication.class, args);
    }
}
=== FIN ===

=== Contenu de backend\api-gateway\src\main\java\com\recruitpme\apigateway\client\AIServiceClient.java ===
package com.recruitpme.apigateway.client;

import org.springframework.stereotype.Component;
import com.recruitpme.apigateway.model.AnalysisResult;
import java.util.List; 
@Component
public class AIServiceClient {

    public static class AnalysisRequest {
        private String text;
        private String jobId;

        public AnalysisRequest(String text, String jobId) {
            this.text = text;
            this.jobId = jobId;
        }

        public String getText() {
            return text;
        }

        public String getJobId() {
            return jobId;
        }
    }

    public AnalysisResult analyze(AnalysisRequest request) {
        // TODO: Implémenter l'appel réel au service ai-service
        AnalysisResult result = new AnalysisResult();
        result.setSkills(List.of("Java", "Spring Boot"));
        result.setExperience("5 years");
        result.setScore(85);
        return result;
    }
}
=== FIN ===

=== Contenu de backend\api-gateway\src\main\java\com\recruitpme\apigateway\config\AuthenticationFilter.java ===
package com.recruitpme.apigateway.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

@Component
@Slf4j
public class AuthenticationFilter extends AbstractGatewayFilterFactory<AuthenticationFilter.Config> {

    private final WebClient.Builder webClientBuilder;
    private final RouteValidator routeValidator;

    public AuthenticationFilter(WebClient.Builder webClientBuilder, RouteValidator routeValidator) {
        super(Config.class);
        this.webClientBuilder = webClientBuilder;
        this.routeValidator = routeValidator;
    }

    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
            ServerHttpRequest request = exchange.getRequest();

            // Skip validation for non-secured endpoints
            if (!routeValidator.isSecured(request)) {
                return chain.filter(exchange);
            }

            // Check for Authorization header
            if (!request.getHeaders().containsKey(HttpHeaders.AUTHORIZATION)) {
                return onError(exchange, "Authorization header is missing", HttpStatus.UNAUTHORIZED);
            }

            String authHeader = request.getHeaders().getFirst(HttpHeaders.AUTHORIZATION);
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return onError(exchange, "Invalid authorization header", HttpStatus.UNAUTHORIZED);
            }

            String token = authHeader.substring(7);

            // Validate token with auth service
            return webClientBuilder.build()
                    .get()
                    .uri("http://localhost:8081/api/auth/validate-token?token=" + token)
                    .retrieve()
                    .bodyToMono(Boolean.class)
                    .flatMap(isValid -> {
                        if (isValid) {
                            return chain.filter(exchange);
                        } else {
                            return onError(exchange, "Invalid token", HttpStatus.UNAUTHORIZED);
                        }
                    })
                    .onErrorResume(error -> {
                        log.error("Error validating token: {}", error.getMessage());
                        return onError(exchange, "Token validation failed", HttpStatus.INTERNAL_SERVER_ERROR);
                    });
        };
    }

    private Mono<Void> onError(ServerWebExchange exchange, String message, HttpStatus httpStatus) {
        ServerHttpResponse response = exchange.getResponse();
        response.setStatusCode(httpStatus);
        return response.setComplete();
    }

    public static class Config {
        // Configuration properties if needed
    }
}
=== FIN ===

=== Contenu de backend\api-gateway\src\main\java\com\recruitpme\apigateway\config\CorsConfig.java ===

package com.recruitpme.apigateway.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsWebFilter;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
public class CorsConfig {
    @Bean
    public CorsWebFilter corsWebFilter() {
        CorsConfiguration corsConfig = new CorsConfiguration();
        corsConfig.setAllowedOrigins(Arrays.asList("http://localhost:3000")); // In production, restrict to your frontend domain
        corsConfig.setAllowCredentials(true);
        corsConfig.setMaxAge(3600L);
        corsConfig.setAllowedMethods(Arrays.asList(
                HttpMethod.GET.name(),
                HttpMethod.POST.name(),
                HttpMethod.PUT.name(),
                HttpMethod.DELETE.name(),
                HttpMethod.OPTIONS.name()
        ));
        corsConfig.setAllowedHeaders(Arrays.asList("*"));
        corsConfig.setExposedHeaders(Arrays.asList("Authorization"));

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", corsConfig);

        return new CorsWebFilter(source);
    }
}
=== FIN ===

=== Contenu de backend\api-gateway\src\main\java\com\recruitpme\apigateway\config\GatewayConfig.java ===

package com.recruitpme.apigateway.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import java.util.ArrayList;
import java.util.List;

@Configuration
@ConfigurationProperties(prefix = "gateway")
@Data
public class GatewayConfig {

    private List<String> excludedUrls = new ArrayList<>();
}
=== FIN ===

=== Contenu de backend\api-gateway\src\main\java\com\recruitpme\apigateway\config\RouteValidator.java ===
package com.recruitpme.apigateway.config;

import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.function.Predicate;

/**
 * This class validates if a route should be secured or not
 */
@Component
public class RouteValidator {

    public static final List<String> openApiEndpoints = List.of(
            "/api/auth/login",
            "/api/auth/register",
            "/api/auth/forgot-password",
            "/api/auth/reset-password"
    );

    /**
     * Predicate to test if a request is for a secured endpoint
     * @param request The HTTP request to check
     * @return true if the request should be secured, false otherwise
     */
    public boolean isSecured(ServerHttpRequest request) {
        return openApiEndpoints
                .stream()
                .noneMatch(uri -> request.getURI().getPath().contains(uri));
    }
}
=== FIN ===

=== Contenu de backend\api-gateway\src\main\java\com\recruitpme\apigateway\exception\CVAnalysisException.java ===

package com.recruitpme.apigateway.exception;

public class CVAnalysisException extends RuntimeException {
    public CVAnalysisException(String message, Throwable cause) {
        super(message, cause);
    }
}
=== FIN ===

=== Contenu de backend\api-gateway\src\main\java\com\recruitpme\apigateway\model\AnalysisResult.java ===
package com.recruitpme.apigateway.model;
import java.util.List;
import lombok.Data;

@Data
public class AnalysisResult {
    private List<String> skills;
    private String experience;
    private int score;
}
=== FIN ===

=== Contenu de backend\api-gateway\src\main\java\com\recruitpme\apigateway\utils\TextExtractor.java ===
package com.recruitpme.apigateway.utils;

import java.io.InputStream;

public class TextExtractor {
    public static String extract(InputStream inputStream) {
        // TODO: Implémenter l'extraction réelle du texte
        return "Sample extracted text from CV";
    }
}
=== FIN ===

=== Contenu de backend\api-gateway\src\main\resources\application.properties ===
# Server configuration
server.port=8080
spring.application.name=api-gateway

# Gateway configuration
spring.cloud.gateway.discovery.locator.enabled=true
spring.cloud.gateway.discovery.locator.lower-case-service-id=true

# Routes configuration
# Auth Service
spring.cloud.gateway.routes[0].id=auth-service
spring.cloud.gateway.routes[0].uri=http://localhost:8081
spring.cloud.gateway.routes[0].predicates[0]=Path=/api/auth/**
spring.cloud.gateway.routes[0].filters[0]=AuthenticationFilter

# CV Service
spring.cloud.gateway.routes[1].id=cv-service
spring.cloud.gateway.routes[1].uri=http://localhost:8082
spring.cloud.gateway.routes[1].predicates[0]=Path=/api/cv/**
spring.cloud.gateway.routes[1].filters[0]=AuthenticationFilter

# Job Service
spring.cloud.gateway.routes[2].id=job-service
spring.cloud.gateway.routes[2].uri=http://localhost:8083
spring.cloud.gateway.routes[2].predicates[0]=Path=/api/jobs/**
spring.cloud.gateway.routes[2].filters[0]=AuthenticationFilter

# Interview Service
spring.cloud.gateway.routes[3].id=interview-service
spring.cloud.gateway.routes[3].uri=http://localhost:8084
spring.cloud.gateway.routes[3].predicates[0]=Path=/api/interviews/**
spring.cloud.gateway.routes[3].filters[0]=AuthenticationFilter

# Notification Service
spring.cloud.gateway.routes[4].id=notification-service
spring.cloud.gateway.routes[4].uri=http://localhost:8085
spring.cloud.gateway.routes[4].predicates[0]=Path=/api/notifications/**
spring.cloud.gateway.routes[4].filters[0]=AuthenticationFilter

# Dashboard API
spring.cloud.gateway.routes[5].id=dashboard-api
#spring.cloud.gateway.routes[5].uri=http://cv-service:8082
spring.cloud.gateway.routes[5].uri=http://localhost:8082
spring.cloud.gateway.routes[5].predicates[0]=Path=/api/dashboard/**
spring.cloud.gateway.routes[5].filters[0]=AuthenticationFilter

# Candidates API - recent candidates
spring.cloud.gateway.routes[6].id=candidates-api
spring.cloud.gateway.routes[6].uri=http://localhost:8082
spring.cloud.gateway.routes[6].predicates[0]=Path=/api/candidates/**
spring.cloud.gateway.routes[6].filters[0]=AuthenticationFilter

# Excluded URLs from authentication
gateway.excludedUrls[0]=/api/auth/login
gateway.excludedUrls[1]=/api/auth/register
gateway.excludedUrls[2]=/api/auth/forgot-password
gateway.excludedUrls[3]=/api/auth/reset-password

# Logging
#logging.level.org.springframework.cloud.gateway=DEBUG
logging.level.org.springframework.cloud.gateway=TRACE
=== FIN ===

=== Contenu de backend\api-gateway\src\test\java\com\recruitpme\apigateway\ApiGatewayApplicationTests.java ===
package com.recruitpme.apigateway;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ApiGatewayApplicationTests {

    @Test
    void contextLoads() {
        // Verify that the application context loads successfully
    }
}
=== FIN ===

=== Contenu de backend\api-gateway\src\test\java\com\recruitpme\apigateway\config\AuthenticationFilterTest.java ===
package com.recruitpme.apigateway.config;

import com.recruitpme.apigateway.config.AuthenticationFilter;
import com.recruitpme.apigateway.config.RouteValidator;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.mock.http.server.reactive.MockServerHttpRequest;
import org.springframework.mock.web.server.MockServerWebExchange;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class AuthenticationFilterTest {

    @Mock
    private GatewayFilterChain filterChain;
    
    @Mock
    private RouteValidator routeValidator;
    
    @Mock
    private WebClient.Builder webClientBuilder;
    
    @InjectMocks
    private AuthenticationFilter filter;

    @Test
    public void testSecuredRouteWithoutAuthHeader() {
        // Configure le mock pour que isSecured retourne true (route sécurisée)
        when(routeValidator.isSecured(any(ServerHttpRequest.class))).thenReturn(true);
        
        // Crée une requête sans en-tête d'autorisation
        MockServerHttpRequest request = MockServerHttpRequest
                .get("http://localhost:8080/api/secured-endpoint")
                .build();
        
        // Crée un échange avec notre requête
        MockServerWebExchange exchange = MockServerWebExchange.from(request);
        
        // Exécute le filtre
        GatewayFilter gatewayFilter = filter.apply(new AuthenticationFilter.Config());
        Mono<Void> result = gatewayFilter.filter(exchange, filterChain);
        
        // Vérifie que le filtre se termine correctement
        StepVerifier.create(result)
                .expectComplete()
                .verify();
        
        // Vérifie que le statut est bien UNAUTHORIZED
        assertEquals(HttpStatus.UNAUTHORIZED, exchange.getResponse().getStatusCode());
        
        // Vérifie que le filtre ne laisse pas passer la requête
        verify(filterChain, never()).filter(any());
    }

    @Test
    public void testSecuredRouteWithInvalidAuthHeader() {
        // Configure le mock pour que isSecured retourne true (route sécurisée)
        when(routeValidator.isSecured(any(ServerHttpRequest.class))).thenReturn(true);
        
        // Crée une requête avec un en-tête d'autorisation invalide
        MockServerHttpRequest request = MockServerHttpRequest
                .get("http://localhost:8080/api/secured-endpoint")
                .header(HttpHeaders.AUTHORIZATION, "Invalid-Format")
                .build();
        
        // Crée un échange avec notre requête
        MockServerWebExchange exchange = MockServerWebExchange.from(request);
        
        // Exécute le filtre
        GatewayFilter gatewayFilter = filter.apply(new AuthenticationFilter.Config());
        Mono<Void> result = gatewayFilter.filter(exchange, filterChain);
        
        // Vérifie que le filtre se termine correctement
        StepVerifier.create(result)
                .expectComplete()
                .verify();
        
        // Vérifie que le statut est bien UNAUTHORIZED
        assertEquals(HttpStatus.UNAUTHORIZED, exchange.getResponse().getStatusCode());
        
        // Vérifie que le filtre ne laisse pas passer la requête
        verify(filterChain, never()).filter(any());
    }

    @Test
    public void testSecuredRouteWithValidToken() {
        // Configure le mock pour que isSecured retourne true (route sécurisée)
        when(routeValidator.isSecured(any(ServerHttpRequest.class))).thenReturn(true);
        
        // Configure la chaîne de mocks pour la validation du token
        WebClient webClient = mock(WebClient.class);
        WebClient.RequestHeadersUriSpec requestHeadersUriSpec = mock(WebClient.RequestHeadersUriSpec.class);
        WebClient.RequestHeadersSpec requestHeadersSpec = mock(WebClient.RequestHeadersSpec.class);
        WebClient.ResponseSpec responseSpec = mock(WebClient.ResponseSpec.class);
        
        when(webClientBuilder.build()).thenReturn(webClient);
        when(webClient.get()).thenReturn(requestHeadersUriSpec);
        when(requestHeadersUriSpec.uri(anyString())).thenReturn(requestHeadersSpec);
        when(requestHeadersSpec.retrieve()).thenReturn(responseSpec);
        when(responseSpec.bodyToMono(Boolean.class)).thenReturn(Mono.just(true));
        
        when(filterChain.filter(any())).thenReturn(Mono.empty());
        
        // Crée une requête avec un en-tête d'autorisation valide
        MockServerHttpRequest request = MockServerHttpRequest
                .get("http://localhost:8080/api/secured-endpoint")
                .header(HttpHeaders.AUTHORIZATION, "Bearer valid-token")
                .build();
        
        // Crée un échange avec notre requête
        MockServerWebExchange exchange = MockServerWebExchange.from(request);
        
        // Exécute le filtre
        GatewayFilter gatewayFilter = filter.apply(new AuthenticationFilter.Config());
        Mono<Void> result = gatewayFilter.filter(exchange, filterChain);
        
        // Vérifie que le filtre se termine correctement
        StepVerifier.create(result)
                .expectComplete()
                .verify();
        
        // Vérifie que le filtre laisse passer la requête
        verify(filterChain).filter(exchange);
    }

    @Test
    public void testNonSecuredRoute() {
        // Configure le mock pour que isSecured retourne false (route non sécurisée)
        when(routeValidator.isSecured(any(ServerHttpRequest.class))).thenReturn(false);
        
        when(filterChain.filter(any())).thenReturn(Mono.empty());
        
        // Crée une requête sans en-tête d'autorisation
        MockServerHttpRequest request = MockServerHttpRequest
                .get("http://localhost:8080/api/public-endpoint")
                .build();
        
        // Crée un échange avec notre requête
        MockServerWebExchange exchange = MockServerWebExchange.from(request);
        
        // Exécute le filtre
        GatewayFilter gatewayFilter = filter.apply(new AuthenticationFilter.Config());
        Mono<Void> result = gatewayFilter.filter(exchange, filterChain);
        
        // Vérifie que le filtre se termine correctement
        StepVerifier.create(result)
                .expectComplete()
                .verify();
        
        // Vérifie que le filtre laisse passer la requête
        verify(filterChain).filter(exchange);
    }
}
=== FIN ===

=== Contenu de backend\api-gateway\src\test\resources\application-test.properties ===
# Configuration spécifique aux tests
spring.cloud.gateway.discovery.locator.enabled=false
spring.cloud.gateway.routes[0].id=auth-service
spring.cloud.gateway.routes[0].uri=http://auth-service:8081
spring.cloud.gateway.routes[0].predicates[0]=Path=/api/auth/**

spring.cloud.gateway.routes[1].id=cv-service
spring.cloud.gateway.routes[1].uri=http://cv-service:8082
spring.cloud.gateway.routes[1].predicates[0]=Path=/api/cv/**

# Autres routes pour les tests

# Endpoints exclus de l'authentification pour les tests
gateway.excludedUrls[0]=/api/auth/login
gateway.excludedUrls[1]=/api/auth/register
=== FIN ===

=== Contenu de backend\auth-service\Dockerfile ===
FROM eclipse-temurin:17-jre
WORKDIR /app
COPY target/*.jar app.jar


EXPOSE 8081
ENTRYPOINT ["java", "-jar", "app.jar"]

=== FIN ===


=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\AuthServiceApplication.java ===
package com.recruitpme.authservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class AuthServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(AuthServiceApplication.class, args);
    }
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\config\JavaMailConfig.java ===
package com.recruitpme.authservice.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.JavaMailSenderImpl;
import java.util.Properties;

@Configuration
public class JavaMailConfig {

    @Bean
    public JavaMailSender javaMailSender() {
        JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
        mailSender.setHost("smtp.gmail.com");
        mailSender.setPort(587);
        mailSender.setUsername("dummy@example.com");
        mailSender.setPassword("dummy");
        
        Properties props = mailSender.getJavaMailProperties();
        props.put("mail.transport.protocol", "smtp");
        props.put("mail.smtp.auth", "true");
        props.put("mail.smtp.starttls.enable", "true");
        props.put("mail.debug", "false");
        
        return mailSender;
    }
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\config\WebConfig.java ===
package com.recruitpme.authservice.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
@Configuration
public class WebConfig implements WebMvcConfigurer {

//    @Override
//    public void addCorsMappings(CorsRegistry registry) {
//        registry.addMapping("/**")
//                .allowedOrigins("http://localhost:3000")
//                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
//                .allowedHeaders("*")
//                .allowCredentials(true)
//                .maxAge(3600);
//    }
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\controller\AuthController.java ===
package com.recruitpme.authservice.controller;

import com.recruitpme.authservice.dto.LoginRequest;
import com.recruitpme.authservice.dto.LoginResponse;
import com.recruitpme.authservice.dto.RegistrationRequest;
import com.recruitpme.authservice.dto.UserDTO;
import com.recruitpme.authservice.service.AuthService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import javax.validation.Valid;
import java.util.Map;
import java.util.HashMap;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
@Slf4j
public class AuthController {

    private final AuthService authService;

    @PostMapping("/login")
    public ResponseEntity<LoginResponse> login(@Valid @RequestBody LoginRequest request) {
        log.info("Login attempt for user: {}", request.getEmail());
        LoginResponse response = authService.login(request.getEmail(), request.getPassword());
        return ResponseEntity.ok(response);
    }

    @PostMapping("/register")
    public ResponseEntity<UserDTO> register(@Valid @RequestBody RegistrationRequest request) {
        log.info("Registration attempt for user: {}", request.getEmail());
        UserDTO user = authService.register(request);
        return ResponseEntity.ok(user);
    }

//    @ExceptionHandler(Exception.class)
//    public ResponseEntity<Map<String, String>> handleException(Exception ex) {
//        log.error("Error in AuthController: {}", ex.getMessage());
//        Map<String, String> error = new HashMap<>();
//        error.put("error", ex.getMessage());
//        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
//    }

    @PostMapping("/forgot-password")
    public ResponseEntity<Map<String, String>> forgotPassword(@RequestBody Map<String, String> request) {
        String email = request.get("email");
        log.info("Password reset request for email: {}", email);
        authService.initiatePasswordReset(email);

        Map<String, String> response = new HashMap<>();
        response.put("message", "Password reset email sent if account exists");
        return ResponseEntity.ok(response);
    }

    @PostMapping("/reset-password")
    public ResponseEntity<Map<String, String>> resetPassword(@RequestBody Map<String, String> request) {
        String token = request.get("token");
        String password = request.get("password");
        log.info("Password reset attempt with token");
        authService.resetPassword(token, password);

        Map<String, String> response = new HashMap<>();
        response.put("message", "Password reset successful");
        return ResponseEntity.ok(response);
    }

    @GetMapping("/me")
    public ResponseEntity<UserDTO> getCurrentUser() {
        UserDTO user = authService.getCurrentUser();
        return ResponseEntity.ok(user);
    }

    @PostMapping("/logout")
    public ResponseEntity<Map<String, String>> logout() {
        authService.logout();

        Map<String, String> response = new HashMap<>();
        response.put("message", "Logout successful");
        return ResponseEntity.ok(response);
    }
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\dto\LoginRequest.java ===
package com.recruitpme.authservice.dto;

import lombok.Data;

import javax.validation.constraints.Email;
import javax.validation.constraints.NotBlank;
@Data
public class LoginRequest {
    
    @NotBlank(message = "L'email est obligatoire")
    @Email(message = "Format d'email invalide")
    private String email;
    
    @NotBlank(message = "Le mot de passe est obligatoire")
    private String password;
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\dto\LoginResponse.java ===
package com.recruitpme.authservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginResponse {
    private String token;
    private UserDTO user;
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\dto\PasswordResetRequest.java ===
// PasswordResetRequest.java
package com.recruitpme.authservice.dto;

import lombok.Data;

import javax.validation.constraints.NotBlank;


@Data
public class PasswordResetRequest {
    @NotBlank(message = "Le token est obligatoire")
    private String token;
    
    @NotBlank(message = "Le mot de passe est obligatoire")
    private String password;
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\dto\PasswordResetTokenDTO.java ===


=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\dto\RegistrationRequest.java ===
package com.recruitpme.authservice.dto;

import lombok.Data;

import javax.validation.constraints.Email;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Pattern;
import javax.validation.constraints.Size;


@Data
public class RegistrationRequest {
    
    @NotBlank(message = "L'email est obligatoire")
    @Email(message = "Format d'email invalide")
    private String email;
    
    @NotBlank(message = "Le mot de passe est obligatoire")
    @Size(min = 8, message = "Le mot de passe doit contenir au moins 8 caractères")
    private String password;
    
    @NotBlank(message = "Le prénom est obligatoire")
    private String firstName;
    
    @NotBlank(message = "Le nom est obligatoire")
    private String lastName;
    
    private String companyName;
    
    @Pattern(regexp = "^[+]?[(]?[0-9]{1,4}[)]?[-\\s.]?[0-9]{1,12}$", message = "Format de téléphone invalide")
    private String phoneNumber;
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\dto\UserDTO.java ===
package com.recruitpme.authservice.dto;

import lombok.Data;

import java.time.LocalDateTime;


@Data
public class UserDTO {
    private Long id;
    private String email;
    private String firstName;
    private String lastName;
    private String companyName;
    private String phoneNumber;
    private String role;
    private boolean enabled;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\entity\PasswordResetToken.java ===
package com.recruitpme.authservice.entity;


import lombok.Data;

import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToOne;
import javax.persistence.Table;
import java.time.LocalDateTime;

@Entity
@Table(name = "password_reset_tokens")
@Data
public class PasswordResetToken {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String token;
    
    @OneToOne(targetEntity = User.class, fetch = FetchType.EAGER)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    private LocalDateTime expiryDate;
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\entity\Role.java ===
package com.recruitpme.authservice.entity;

import lombok.Data;


import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "roles")
@Data
public class Role {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\entity\User.java ===
package com.recruitpme.authservice.entity;

import lombok.Data;


import javax.persistence.*;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "users")
@Data
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false)
    private String email;
    
    @Column(nullable = false)
    private String password;
    
    private String firstName;
    
    private String lastName;
    
    private String companyName;
    
    private String phoneNumber;
    
    private boolean enabled;
    
    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<Role> roles = new HashSet<>();
    
    private LocalDateTime createdAt;
    
    private LocalDateTime updatedAt;
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\event\OnRegistrationCompleteEvent.java ===
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\exception\AuthenticationException.java ===
package com.recruitpme.authservice.exception;


public class AuthenticationException extends RuntimeException {
    
    public AuthenticationException(String message) {
        super(message);
    }
    
    public AuthenticationException(String message, Throwable cause) {
        super(message, cause);
    }
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\exception\ResourceNotFoundException.java ===
package com.recruitpme.authservice.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;


@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    
    public ResourceNotFoundException(String message) {
        super(message);
    }
    
    public ResourceNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\listener\RegistrationListener.java ===


=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\repository\PasswordResetTokenRepository.java ===
package com.recruitpme.authservice.repository;


import com.recruitpme.authservice.entity.PasswordResetToken;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface PasswordResetTokenRepository extends JpaRepository<PasswordResetToken, Long> {
    
    Optional<PasswordResetToken> findByToken(String token);
    
    void deleteByUserId(Long userId);
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\repository\RoleRepository.java ===
package com.recruitpme.authservice.repository;

import com.recruitpme.authservice.entity.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;


import java.util.Optional;

@Repository
public interface RoleRepository extends JpaRepository<Role, Long> {
    
    Optional<Role> findByName(String name);
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\repository\UserRepository.java ===
package com.recruitpme.authservice.repository;

import com.recruitpme.authservice.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;


import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    Optional<User> findByEmail(String email);
    
    boolean existsByEmail(String email);
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\security\JwtAuthenticationEntryPoint.java ===
package com.recruitpme.authservice.security;

import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.AuthenticationException;

import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
@Slf4j
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException {
        log.error("Unauthorized error: {}", authException.getMessage());
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Non autorisé: " + authException.getMessage());
    }
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\security\JwtAuthenticationFilter.java ===
package com.recruitpme.authservice.security;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;

import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
@RequiredArgsConstructor
@Slf4j
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider tokenProvider;
    private final UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String jwt = getJwtFromRequest(request);

            if (StringUtils.hasText(jwt) && tokenProvider.validateToken(jwt)) {
                String username = tokenProvider.getUsernameFromToken(jwt);

                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            log.error("Cannot set user authentication: {}", e.getMessage());
        }

        filterChain.doFilter(request, response);
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\security\JwtTokenProvider.java ===
package com.recruitpme.authservice.security;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;

import org.springframework.stereotype.Component;

import java.util.Base64;
import java.util.Date;
import java.util.function.Function;

@Component
@Slf4j
public class JwtTokenProvider {

    @Value("${jwt.secret}")
    private String jwtSecret;

    @Value("${jwt.expiration}")
    private long jwtExpirationInMs;


    public JwtTokenProvider(@Value("${jwt.secret}") String jwtSecret,
                            @Value("${jwt.expiration}") long jwtExpirationInMs) {
        try {
            Base64.getDecoder().decode(jwtSecret); // Valide que la clé est en Base64
            this.jwtSecret = jwtSecret;
        } catch (IllegalArgumentException e) {
            throw new IllegalStateException("Invalid JWT secret key: must be Base64 encoded", e);
        }
        this.jwtExpirationInMs = jwtExpirationInMs;
    }

    public String generateToken(Authentication authentication) {
        UserDetails userDetails = (UserDetails) authentication.getPrincipal();
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpirationInMs);
        
        return Jwts.builder()
                .setSubject(userDetails.getUsername())
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(SignatureAlgorithm.HS512, jwtSecret)
                .compact();
    }

    public String getUsernameFromToken(String token) {
        return getClaimFromToken(token, Claims::getSubject);
    }

    public boolean validateToken(String token, UserDetails userDetails) {
        final String username = getUsernameFromToken(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            log.error("JWT validation error: {}", e.getMessage());
            return false;
        }
    }

    private <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = getAllClaimsFromToken(token);
        return claimsResolver.apply(claims);
    }

    private Claims getAllClaimsFromToken(String token) {
        return Jwts.parser()
                .setSigningKey(jwtSecret)
                .parseClaimsJws(token)
                .getBody();
    }

    private boolean isTokenExpired(String token) {
        final Date expiration = getExpirationDateFromToken(token);
        return expiration.before(new Date());
    }

    private Date getExpirationDateFromToken(String token) {
        return getClaimFromToken(token, Claims::getExpiration);
    }
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\security\SecurityConfig.java ===
package com.recruitpme.authservice.security;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;

import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
@RequiredArgsConstructor
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    private final UserDetailsService userDetailsService;
    private final JwtAuthenticationEntryPoint unauthorizedHandler;
    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService)
            .passwordEncoder(passwordEncoder());
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .cors().and().csrf().disable()
            .exceptionHandling().authenticationEntryPoint(unauthorizedHandler).and()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()
            .authorizeRequests()
            .antMatchers("/api/auth/login", "/api/auth/register", "/api/auth/forgot-password", "/api/auth/reset-password").permitAll()
            .anyRequest().authenticated();
        
        http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
    }

    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\security\UserDetailsServiceImpl.java ===
package com.recruitpme.authservice.security;

import com.recruitpme.authservice.entity.User;
import com.recruitpme.authservice.repository.UserRepository;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.stream.Collectors;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserRepository userRepository;

    public UserDetailsServiceImpl(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with email: " + email));
        return new org.springframework.security.core.userdetails.User(
                user.getEmail(),
                user.getPassword(),
                user.isEnabled(),
                true, true, true, // accountNonExpired, credentialsNonExpired, accountNonLocked
                user.getRoles().stream()
                        .map(role -> new org.springframework.security.core.authority.SimpleGrantedAuthority(role.getName()))
                        .collect(Collectors.toList())
        );
    }
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\service\AuthService.java ===
package com.recruitpme.authservice.service;

import com.recruitpme.authservice.dto.LoginResponse;
import com.recruitpme.authservice.dto.RegistrationRequest;
import com.recruitpme.authservice.dto.UserDTO;


public interface AuthService {
    
    LoginResponse login(String email, String password);
    
    UserDTO register(RegistrationRequest request);
    
    void initiatePasswordReset(String email);
    
    void resetPassword(String token, String newPassword);
    
    UserDTO getCurrentUser();
    
    void logout();
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\service\AuthServiceImpl.java ===
package com.recruitpme.authservice.service;

import com.recruitpme.authservice.dto.LoginResponse;
import com.recruitpme.authservice.dto.RegistrationRequest;
import com.recruitpme.authservice.dto.UserDTO;
import com.recruitpme.authservice.entity.PasswordResetToken;
import com.recruitpme.authservice.entity.Role;
import com.recruitpme.authservice.entity.User;
import com.recruitpme.authservice.exception.AuthenticationException;
import com.recruitpme.authservice.exception.ResourceNotFoundException;
import com.recruitpme.authservice.repository.PasswordResetTokenRepository;
import com.recruitpme.authservice.repository.RoleRepository;
import com.recruitpme.authservice.repository.UserRepository;
import com.recruitpme.authservice.security.JwtTokenProvider;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class AuthServiceImpl implements AuthService {

    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final PasswordResetTokenRepository tokenRepository;
    private final PasswordEncoder passwordEncoder;
    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider tokenProvider;
    private final EmailService emailService;

//    public LoginResponse login(String email, String password) {
//        try {
//            log.info("Attempting authentication for email: {}, password: [PROTECTED]", email);
//            Authentication authentication = authenticationManager.authenticate(
//                    new UsernamePasswordAuthenticationToken(email, password)
//            );
//            SecurityContextHolder.getContext().setAuthentication(authentication);
//            User user = userRepository.findByEmail(email)
//                    .orElseThrow(() -> new ResourceNotFoundException("User not found with email: " + email));
//            String token = tokenProvider.generateToken(authentication);
//            log.info("Login successful for email: {}", email);
//            return new LoginResponse(token, convertToDTO(user));
//        } catch (Exception e) {
//            log.error("Login failed for user: {}, error: {}, stack trace: {}", email, e.getMessage(), e.getStackTrace());
//            throw new AuthenticationException("Invalid email or password");
//        }
//    }

    @Override
    public LoginResponse login(String email, String password) {
        try {
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(email, password)
            );

            SecurityContextHolder.getContext().setAuthentication(authentication);

            User user = userRepository.findByEmail(email)
                    .orElseThrow(() -> new ResourceNotFoundException("User not found with email: " + email));

            String token = tokenProvider.generateToken(authentication);

            return new LoginResponse(token, convertToDTO(user));
        } catch (Exception e) {
            log.error("Login failed for user: {}, error: {}", email, e.getMessage());
            throw new AuthenticationException("Invalid email or password");
        }
    }

    @Override
    @Transactional
    public UserDTO register(RegistrationRequest request) {
        // Check if user already exists
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new AuthenticationException("Email already in use: " + request.getEmail());
        }

        // Create new user
        User user = new User();
        user.setEmail(request.getEmail());
        user.setPassword(passwordEncoder.encode(request.getPassword()));
        user.setFirstName(request.getFirstName());
        user.setLastName(request.getLastName());
        user.setCompanyName(request.getCompanyName());
        user.setPhoneNumber(request.getPhoneNumber());
        user.setEnabled(true);
        user.setCreatedAt(LocalDateTime.now());

        // Assign default role (ROLE_USER)
        Role userRole = roleRepository.findByName("ROLE_USER")
                .orElseGet(() -> {
                    Role newRole = new Role();
                    newRole.setName("ROLE_USER");
                    return roleRepository.save(newRole);
                });
        // Create a set and add the role
        Set<Role> roleSet = new HashSet<>();
        roleSet.add(userRole);
        user.setRoles(roleSet);

        User savedUser = userRepository.save(user);

        // Send welcome email
        emailService.sendWelcomeEmail(user.getEmail(), user.getFirstName());

        return convertToDTO(savedUser);
    }

    @Override
    @Transactional
    public void initiatePasswordReset(String email) {
        userRepository.findByEmail(email).ifPresent(user -> {
            // Generate reset token
            String token = UUID.randomUUID().toString();

            // Save token
            PasswordResetToken passwordResetToken = new PasswordResetToken();
            passwordResetToken.setToken(token);
            passwordResetToken.setUser(user);
            passwordResetToken.setExpiryDate(LocalDateTime.now().plusHours(24));

            tokenRepository.save(passwordResetToken);

            // Send email with reset link
            emailService.sendPasswordResetEmail(user.getEmail(), user.getFirstName(), token);
        });
    }

    @Override
    @Transactional
    public void resetPassword(String token, String newPassword) {
        PasswordResetToken resetToken = tokenRepository.findByToken(token)
                .orElseThrow(() -> new AuthenticationException("Invalid or expired password reset token"));

        // Check if token is expired
        if (resetToken.getExpiryDate().isBefore(LocalDateTime.now())) {
            tokenRepository.delete(resetToken);
            throw new AuthenticationException("Password reset token has expired");
        }

        // Update password
        User user = resetToken.getUser();
        user.setPassword(passwordEncoder.encode(newPassword));
        user.setUpdatedAt(LocalDateTime.now());

        userRepository.save(user);

        // Delete used token
        tokenRepository.delete(resetToken);
    }

    @Override
    public UserDTO getCurrentUser() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String email = authentication.getName();

        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with email: " + email));

        return convertToDTO(user);
    }

    @Override
    public void logout() {
        // JWT tokens are stateless, so no server-side logout is needed
        // Client-side token removal is handled by the frontend
        SecurityContextHolder.clearContext();
    }

    private UserDTO convertToDTO(User user) {
        UserDTO dto = new UserDTO();
        dto.setId(user.getId());
        dto.setEmail(user.getEmail());
        dto.setFirstName(user.getFirstName());
        dto.setLastName(user.getLastName());
        dto.setCompanyName(user.getCompanyName());
        dto.setPhoneNumber(user.getPhoneNumber());
        dto.setRole(user.getRoles().iterator().next().getName());
        dto.setEnabled(user.isEnabled());
        dto.setCreatedAt(user.getCreatedAt());

        return dto;
    }
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\service\DummyEmailServiceImpl.java ===
package com.recruitpme.authservice.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;


@Service
@Slf4j
@Profile("dev") // Utilisez ce service uniquement pour le profil "dev"
public class DummyEmailServiceImpl implements EmailService {

    @Override
    public void sendWelcomeEmail(String to, String firstName) {
        log.info("DUMMY EMAIL SERVICE - Welcome email would be sent to: {}", to);
    }

    @Override
    public void sendPasswordResetEmail(String to, String firstName, String token) {
        log.info("DUMMY EMAIL SERVICE - Password reset email would be sent to: {}", to);
        log.info("Reset token: {}", token);
    }
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\service\EmailService.java ===
package com.recruitpme.authservice.service;

public interface EmailService {
    
    void sendWelcomeEmail(String to, String firstName);
    
    void sendPasswordResetEmail(String to, String firstName, String token);
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\java\com\recruitpme\authservice\service\EmailServiceImpl.java ===
package com.recruitpme.authservice.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;


@Service
@Slf4j
public class EmailServiceImpl implements EmailService {
    
    private final JavaMailSender emailSender;
    private final boolean emailEnabled;
    
    @Value("${spring.mail.username:noreply@example.com}")
    private String fromEmail;
    
    @Value("${app.url:http://localhost:3000}")
    private String appUrl;
    
    @Autowired(required = false)
    public EmailServiceImpl(JavaMailSender emailSender) {
        this.emailSender = emailSender;
        this.emailEnabled = (emailSender != null);
    }
    
    @Override
    public void sendWelcomeEmail(String to, String firstName) {
        if (!emailEnabled) {
            log.info("Email service disabled. Would send welcome email to: {}", to);
            return;
        }
        
        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setFrom(fromEmail);
            message.setTo(to);
            message.setSubject("Bienvenue sur RecrutPME");
            message.setText("Bonjour " + firstName + ",\n\n" +
                    "Nous vous souhaitons la bienvenue sur RecrutPME, votre plateforme d'analyse de CV par IA.\n\n" +
                    "Vous pouvez dès maintenant commencer à analyser des CV et trouver les meilleurs candidats pour vos postes.\n\n" +
                    "Cordialement,\n" +
                    "L'équipe RecrutPME");
            
            emailSender.send(message);
            log.info("Welcome email sent to: {}", to);
        } catch (Exception e) {
            log.error("Failed to send welcome email to: {}, error: {}", to, e.getMessage());
        }
    }
    
    @Override
    public void sendPasswordResetEmail(String to, String firstName, String token) {
        if (!emailEnabled) {
            log.info("Email service disabled. Would send password reset email to: {}", to);
            return;
        }
        
        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setFrom(fromEmail);
            message.setTo(to);
            message.setSubject("Réinitialisation de votre mot de passe");
            message.setText("Bonjour " + firstName + ",\n\n" +
                    "Vous avez demandé la réinitialisation de votre mot de passe. Veuillez cliquer sur le lien ci-dessous pour définir un nouveau mot de passe:\n\n" +
                    appUrl + "/reset-password?token=" + token + "\n\n" +
                    "Ce lien est valable pendant 24 heures.\n\n" +
                    "Si vous n'avez pas demandé cette réinitialisation, veuillez ignorer cet email.\n\n" +
                    "Cordialement,\n" +
                    "L'équipe RecrutPME");
            
            emailSender.send(message);
            log.info("Password reset email sent to: {}", to);
        } catch (Exception e) {
            log.error("Failed to send password reset email to: {}, error: {}", to, e.getMessage());
        }
    }
}
=== FIN ===

=== Contenu de backend\auth-service\src\main\resources\application.properties ===
server.port=8081
spring.datasource.url=jdbc:postgresql://localhost:5432/auth_db
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.redis.host=redis
spring.redis.port=6379

jwt.secret=A5f8WMizOUTjlsyfVRpfqfbwbt4SOPaUTnVk143/PbRYGaJ7bWn/Ysy2mLD2tPzi945ONCvLUcxxDE0nx6785w==
jwt.expiration=86400000



=== FIN ===

=== Contenu de backend\auth-service\src\test\java\com\recruitpme\authservice\AuthServiceApplicationTests.java ===
package com.recruitpme.authservice;

import org.junit.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
public class AuthServiceApplicationTests {

    /**
     *
     */
    @Test
    public void contextLoads() {
        // Verify that the application context loads successfully
    }
}
=== FIN ===

=== Contenu de backend\auth-service\src\test\java\com\recruitpme\authservice\PasswordTest.java ===
package com.recruitpme.authservice;

import io.jsonwebtoken.SignatureAlgorithm;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import io.jsonwebtoken.security.Keys;
import java.util.Base64;

public class PasswordTest {

    public static void main(String[] args) {
        String secret = Base64.getEncoder().encodeToString(
                Keys.secretKeyFor(SignatureAlgorithm.HS512).getEncoded()
        );
        System.out.println("Secure JWT secret (Base64): " + secret);
    }
}

=== FIN ===

=== Contenu de backend\auth-service\src\test\resources\application-test.properties ===
# Configuration spécifique aux tests
spring.cloud.gateway.discovery.locator.enabled=false
spring.cloud.gateway.routes[0].id=auth-service
spring.cloud.gateway.routes[0].uri=http://auth-service:8081
spring.cloud.gateway.routes[0].predicates[0]=Path=/api/auth/**

spring.cloud.gateway.routes[1].id=cv-service
spring.cloud.gateway.routes[1].uri=http://cv-service:8082
spring.cloud.gateway.routes[1].predicates[0]=Path=/api/cv/**

# Autres routes pour les tests

# Endpoints exclus de l'authentification pour les tests
gateway.excludedUrls[0]=/api/auth/login
gateway.excludedUrls[1]=/api/auth/register
=== FIN ===

=== Contenu de backend\cv-service\Dockerfile ===
FROM eclipse-temurin:17-jre
WORKDIR /app
COPY target/*.jar app.jar

EXPOSE 8082

ENTRYPOINT ["java", "-jar", "app.jar"]

=== FIN ===


=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\CvServiceApplication.java ===
package com.recruitpme.cvservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;


@SpringBootApplication
@EnableFeignClients
@EntityScan("com.recruitpme.cvservice.entity")
@EnableJpaRepositories("com.recruitpme.cvservice.repository")
public class CvServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(CvServiceApplication.class, args);
    }
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\client\AIServiceClient.java ===
package com.recruitpme.cvservice.client;

import com.recruitpme.cvservice.dto.CVAnalysisRequestDTO;
import com.recruitpme.cvservice.dto.CVAnalysisResponseDTO;
import com.recruitpme.cvservice.dto.CVDetailResponseDTO;
import com.recruitpme.cvservice.dto.InterviewQuestionDTO;
import com.recruitpme.cvservice.dto.InterviewQuestionRequestDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

import java.util.List;

@FeignClient(name = "ai-service", url = "${services.ai-service.url}")
public interface AIServiceClient {

    @PostMapping("/api/analyze-cv")
    CVAnalysisResponseDTO analyzeCv(@RequestBody CVAnalysisRequestDTO request);

    @PostMapping("/api/cv-detail")
    CVDetailResponseDTO getCvDetailedInfo(@RequestBody String cvContent);

    @PostMapping("/api/generate-interview-questions")
    List<InterviewQuestionDTO> generateInterviewQuestions(@RequestBody InterviewQuestionRequestDTO request);
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\client\JobServiceClient.java ===
package com.recruitpme.cvservice.client;

import com.recruitpme.cvservice.dto.JobDetailDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(name = "job-service", url = "${services.job-service.url}")
public interface JobServiceClient {

    @GetMapping("/api/jobs/{id}")
    JobDetailDTO getJobDetail(@PathVariable("id") Long id);
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\config\ElasticsearchConfig.java ===
package com.recruitpme.cvservice.config;

import org.elasticsearch.client.RestHighLevelClient;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.elasticsearch.client.ClientConfiguration;
import org.springframework.data.elasticsearch.client.RestClients;
import org.springframework.data.elasticsearch.config.AbstractElasticsearchConfiguration;
import org.springframework.data.elasticsearch.repository.config.EnableElasticsearchRepositories;
import org.springframework.beans.factory.annotation.Value;


@Configuration
@EnableElasticsearchRepositories(basePackages = "com.recruitpme.cvservice.repository")
public class ElasticsearchConfig extends AbstractElasticsearchConfiguration {

    @Value("${spring.elasticsearch.rest.uris}")
    private String elasticsearchUri;

    @Override
    @Bean
    public RestHighLevelClient elasticsearchClient() {
        final ClientConfiguration clientConfiguration = ClientConfiguration.builder()
                .connectedTo(elasticsearchUri.replace("http://", ""))
                .build();

        return RestClients.create(clientConfiguration).rest();
    }
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\config\FeignConfig.java ===
// recruitpme/backend/cv-service/src/main/java/com/recruitpme/cvservice/config/FeignConfig.java
package com.recruitpme.cvservice.config;

import feign.RequestInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;


@Configuration
public class FeignConfig {

    @Bean
    public RequestInterceptor requestInterceptor() {
        return requestTemplate -> {
            ServletRequestAttributes attrs = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
            if (attrs != null) {
                String authHeader = attrs.getRequest().getHeader("Authorization");
                if (authHeader != null) {
                    requestTemplate.header("Authorization", authHeader);
                }
            }
        };
    }
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\config\MinioConfig.java ===
package com.recruitpme.cvservice.config;

import io.minio.MinioClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;



@Configuration
public class MinioConfig {

    @Value("${minio.url}")
    private String url;

    @Value("${minio.access-key}")
    private String accessKey;

    @Value("${minio.secret-key}")
    private String secretKey;

    @Value("${minio.bucket-name}")
    private String bucketName;

    @Bean
    public MinioClient minioClient() {
        return MinioClient.builder()
                .endpoint(url)
                .credentials(accessKey, secretKey)
                .build();
    }
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\config\StorageProperties.java ===
package com.recruitpme.cvservice.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = "storage")
@Data
public class StorageProperties {
    private String location;
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\controller\CandidateController.java ===
package com.recruitpme.cvservice.controller;

import com.recruitpme.cvservice.dto.CandidateDTO;
import com.recruitpme.cvservice.dto.CandidateSearchCriteriaDTO;
import com.recruitpme.cvservice.service.CandidateService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/candidates")
@RequiredArgsConstructor
@Slf4j
public class CandidateController {

    private final CandidateService candidateService;

    @GetMapping
    public ResponseEntity<List<CandidateDTO>> getCandidates(
            @RequestParam(required = false) String status,
            @RequestParam(required = false) String skills,
            @RequestParam(required = false) Integer minScore,
            @RequestParam(required = false, defaultValue = "0") int page,
            @RequestParam(required = false, defaultValue = "20") int size) {

        log.info("Fetching candidates with filters - status: {}, skills: {}, minScore: {}, page: {}, size: {}",
                status, skills, minScore, page, size);

        CandidateSearchCriteriaDTO criteria = new CandidateSearchCriteriaDTO();
        criteria.setStatus(status);
        if (skills != null && !skills.isEmpty()) {
            criteria.setSkills(List.of(skills.split(",")));
        }
        criteria.setMinScore(minScore);
        criteria.setPage(page);
        criteria.setSize(size);

        List<CandidateDTO> candidates = candidateService.findCandidates(criteria);
        return ResponseEntity.ok(candidates);
    }

    @GetMapping("/recent")
    public ResponseEntity<List<CandidateDTO>> getRecentCandidates(
            @RequestParam(required = false, defaultValue = "5") int limit) {

        log.info("Fetching {} most recent candidates", limit);
        List<CandidateDTO> candidates = candidateService.findRecentCandidates(limit);
        return ResponseEntity.ok(candidates);
    }

    @GetMapping("/{id}")
    public ResponseEntity<CandidateDTO> getCandidateById(@PathVariable String id) {
        log.info("Fetching candidate details for ID: {}", id);
        CandidateDTO candidate = candidateService.findById(id);
        return ResponseEntity.ok(candidate);
    }
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\controller\CVController.java ===
package com.recruitpme.cvservice.controller;

import com.recruitpme.cvservice.dto.AnalysisProgressDTO;
import com.recruitpme.cvservice.dto.AnalysisRequestDTO;
import com.recruitpme.cvservice.dto.AnalysisResultDTO;
import com.recruitpme.cvservice.dto.CVDetailDTO;
import com.recruitpme.cvservice.service.CVAnalysisService;
import com.recruitpme.cvservice.service.CVStorageService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/cv")
@RequiredArgsConstructor
@Slf4j
public class CVController {

    private final CVStorageService cvStorageService;
    private final CVAnalysisService cvAnalysisService;

    @PostMapping("/upload")
    public ResponseEntity<?> uploadCV(
            @RequestParam("files") List<MultipartFile> files,
            @RequestParam(value = "jobId", required = false) Long jobId) {

        log.info("Received request to upload {} CV(s)", files.size());

        try {
            List<String> fileIds = cvStorageService.storeFiles(files, jobId);
            return ResponseEntity.ok().body(fileIds);
        } catch (Exception e) {
            log.error("Error uploading CV files", e);
            return ResponseEntity.badRequest().body("Could not upload the files: " + e.getMessage());
        }
    }

    @PostMapping("/analyze")
    public ResponseEntity<?> analyzeCV(
            @RequestParam("files") List<MultipartFile> files,
            @RequestParam("jobId") Long jobId) {

        log.info("Received request to analyze {} CV(s) for job ID: {}", files.size(), jobId);

        try {
            // Store files first
            List<String> fileIds = cvStorageService.storeFiles(files, jobId);

            // Start analysis process
            String analysisId = cvAnalysisService.startBatchAnalysis(fileIds, jobId);

            return ResponseEntity.ok().body(new AnalysisRequestDTO(analysisId));
        } catch (Exception e) {
            log.error("Error analyzing CV files", e);
            return ResponseEntity.badRequest().body("Could not analyze the files: " + e.getMessage());
        }
    }

    @PostMapping("/analyze-single")
    public ResponseEntity<?> analyzeSingleCV(
            @RequestBody AnalysisRequestDTO request) {

        log.info("Received request to analyze CV ID: {} for job ID: {}", request.getCvId(), request.getJobId());

        try {
            AnalysisResultDTO result = cvAnalysisService.analyzeSingleCV(request.getCvId(), request.getJobId());
            return ResponseEntity.ok().body(result);
        } catch (Exception e) {
            log.error("Error analyzing CV", e);
            return ResponseEntity.badRequest().body("Could not analyze the CV: " + e.getMessage());
        }
    }

    @GetMapping("/analyze/progress/{analysisId}")
    public ResponseEntity<AnalysisProgressDTO> getAnalysisProgress(@PathVariable String analysisId) {
        log.info("Checking progress for analysis ID: {}", analysisId);

        AnalysisProgressDTO progress = cvAnalysisService.getAnalysisProgress(analysisId);
        return ResponseEntity.ok().body(progress);
    }

    @GetMapping("/{id}")
    public ResponseEntity<CVDetailDTO> getCVDetail(@PathVariable String id) {
        log.info("Fetching CV details for ID: {}", id);

        try {
            CVDetailDTO cvDetail = cvAnalysisService.getCVDetail(id);
            return ResponseEntity.ok().body(cvDetail);
        } catch (Exception e) {
            log.error("Error fetching CV details", e);
            return ResponseEntity.notFound().build();
        }
    }

    @GetMapping("/download/{id}")
    public ResponseEntity<Resource> downloadCV(@PathVariable String id) {
        log.info("Downloading CV file for ID: {}", id);

        try {
            Resource file = cvStorageService.loadFileAsResource(id);
            String filename = file.getFilename();

            return ResponseEntity.ok()
                    .contentType(MediaType.APPLICATION_OCTET_STREAM)
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + filename + "\"")
                    .body(file);
        } catch (Exception e) {
            log.error("Error downloading CV file", e);
            return ResponseEntity.notFound().build();
        }
    }

    @GetMapping("/view/{id}")
    public ResponseEntity<Resource> viewCV(@PathVariable String id) {
        log.info("Viewing CV file for ID: {}", id);

        try {
            Resource file = cvStorageService.loadFileAsResource(id);

            return ResponseEntity.ok()
                    .contentType(MediaType.APPLICATION_PDF)
                    .body(file);
        } catch (Exception e) {
            log.error("Error viewing CV file", e);
            return ResponseEntity.notFound().build();
        }
    }

    @GetMapping("/candidates/recent")
    public ResponseEntity<List<AnalysisResultDTO>> getRecentCandidates(
            @RequestParam(value = "limit", defaultValue = "5") int limit) {

        log.info("Fetching {} recent candidates", limit);

        try {
            List<AnalysisResultDTO> candidates = cvAnalysisService.getRecentCandidates(limit);
            return ResponseEntity.ok().body(candidates);
        } catch (Exception e) {
            log.error("Error fetching recent candidates", e);
            return ResponseEntity.badRequest().body(null);
        }
    }

    @PostMapping("/talent-pool/add/{id}")
    public ResponseEntity<?> addToTalentPool(@PathVariable String id) {
        log.info("Adding candidate {} to talent pool", id);

        try {
            cvAnalysisService.addToTalentPool(id);
            return ResponseEntity.ok().build();
        } catch (Exception e) {
            log.error("Error adding candidate to talent pool", e);
            return ResponseEntity.badRequest().body("Could not add to talent pool: " + e.getMessage());
        }
    }

    @GetMapping("/talent-pool")
    public ResponseEntity<List<AnalysisResultDTO>> getTalentPool(
            @RequestParam(value = "page", defaultValue = "0") int page,
            @RequestParam(value = "size", defaultValue = "10") int size,
            @RequestParam(value = "skills", required = false) List<String> skills) {

        log.info("Fetching talent pool, page: {}, size: {}", page, size);

        try {
            List<AnalysisResultDTO> candidates = cvAnalysisService.getTalentPool(page, size, skills);
            return ResponseEntity.ok().body(candidates);
        } catch (Exception e) {
            log.error("Error fetching talent pool", e);
            return ResponseEntity.badRequest().body(null);
        }
    }
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\controller\DashboardController.java ===
package com.recruitpme.cvservice.controller;

import com.recruitpme.cvservice.dto.DashboardStatsDTO;
import com.recruitpme.cvservice.service.DashboardService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/dashboard")
@RequiredArgsConstructor
@Slf4j
public class DashboardController {

    private final DashboardService dashboardService;

    @GetMapping
    public ResponseEntity<Map<String, Object>> getDashboardData(
            @RequestParam(value = "period", defaultValue = "30days") String period) {

        log.info("Fetching dashboard data for period: {}", period);
        Map<String, Object> data = dashboardService.getDashboardData(period);
        return ResponseEntity.ok(data);
    }

    @GetMapping("/stats")
    public ResponseEntity<DashboardStatsDTO> getDashboardStats(
            @RequestParam(value = "period", defaultValue = "30days") String period) {

        log.info("Fetching dashboard stats for period: {}", period);
        DashboardStatsDTO stats = dashboardService.getDashboardStats(period);
        return ResponseEntity.ok(stats);
    }

    @GetMapping("/sources")
    public ResponseEntity<List<Map<String, Object>>> getRecruitmentSources() {
        log.info("Fetching recruitment sources data");
        List<Map<String, Object>> sources = dashboardService.getRecruitmentSources();
        return ResponseEntity.ok(sources);
    }
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\dto\AnalysisProgressDTO.java ===
package com.recruitpme.cvservice.dto;

import lombok.Data;

import java.util.ArrayList;
import java.util.List;

@Data
public class AnalysisProgressDTO {
    private String analysisId;
    private int totalDocuments;
    private int processedDocuments;
    private int progress;
    private boolean completed;
    private List<AnalysisResultDTO> results = new ArrayList<>();
    private AnalysisStatsDTO stats;
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\dto\AnalysisRequestDTO.java ===
package com.recruitpme.cvservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AnalysisRequestDTO {
    private String analysisId;
    private String cvId;
    private Long jobId;

    public AnalysisRequestDTO(String analysisId) {
        this.analysisId = analysisId;
    }
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\dto\AnalysisResultDTO.java ===
package com.recruitpme.cvservice.dto;

import lombok.Data;

import java.util.List;

@Data
public class AnalysisResultDTO {
    private String id;
    private String firstName;
    private String lastName;
    private String email;
    private String phone;
    private String title;
    private int yearsOfExperience;
    private int score;
    private List<String> skills;
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\dto\AnalysisStatsDTO.java ===
package com.recruitpme.cvservice.dto;

import lombok.Data;

@Data
public class AnalysisStatsDTO {
    private int skillsDetected;
    private int recommendedCandidates;
    private String topCandidateName;
    private int topCandidateScore;
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\dto\CandidateDTO.java ===
package com.recruitpme.cvservice.dto;

import lombok.Data;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Data
public class CandidateDTO {
    private String id;
    private String firstName;
    private String lastName;
    private String email;
    private String phone;
    private String title;
    private String location;
    private String status;
    private List<String> skills = new ArrayList<>();
    private List<Experience> experience = new ArrayList<>();
    private List<Education> education = new ArrayList<>();
    private Integer score;
    private Long jobId;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    @Data
    public static class Experience {
        private String title;
        private String company;
        private String location;
        private String period;
        private String description;
    }

    @Data
    public static class Education {
        private String degree;
        private String institution;
        private String period;
    }
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\dto\CandidateNoteDTO.java ===
package com.recruitpme.cvservice.dto;

import lombok.Data;
import java.time.LocalDateTime;

@Data
public class CandidateNoteDTO {
    private Long id;
    private String authorName;
    private String authorInitials;
    private String content;
    private String type; // Type de note (entretien, évaluation, etc.)
    private LocalDateTime date;
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\dto\CVAnalysisRequestDTO.java ===
package com.recruitpme.cvservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CVAnalysisRequestDTO {
    private String cvContent;
    private List<String> requiredSkills;
    private List<String> preferredSkills;
    private int minYearsExperience;
    private String jobDescription;
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\dto\CVAnalysisResponseDTO.java ===
package com.recruitpme.cvservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CVAnalysisResponseDTO {
    private String firstName;
    private String lastName;
    private String email;
    private String phone;
    private String title;
    private int yearsOfExperience;
    private int score;
    private List<String> extractedSkills;
    private List<String> matchedSkills;
    private List<String> missingSkills;
    private List<String> strengths;
    private List<String> weaknesses;
    private String detailedAnalysis;
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\dto\CVDetailDTO.java ===
package com.recruitpme.cvservice.dto;

import lombok.Data;

import java.util.List;

@Data
public class CVDetailDTO {
    private String id;
    private String firstName;
    private String lastName;
    private String email;
    private String phone;
    private String title;
    private List<CandidateNoteDTO> notes;
    private int yearsOfExperience;
    private int score;
    private List<String> skills;
    private List<Object> experience;
    private List<Object> education;
    private List<SkillAnalysisDTO> requiredSkillsAnalysis;
    private List<SkillAnalysisDTO> preferredSkillsAnalysis;
    private int requiredSkillsMatch;
    private int requiredSkillsTotal;
    private int preferredSkillsMatch;
    private int preferredSkillsTotal;
    private List<String> strengths;
    private List<String> areasForImprovement;
    private String jobFitAnalysis;
    private List<String> experienceInsights;
    private List<String> educationInsights;
    private List<CategoryScore> categoryScores;
    private List<InterviewQuestionDTO> interviewQuestions;
//    private List<Object> notes;
}

@Data
class CategoryScore {
    private String name;
    private int score;
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\dto\CVDetailResponseDTO.java ===
package com.recruitpme.cvservice.dto;

import lombok.Data;

import java.util.List;

@Data
public class CVDetailResponseDTO {
    private String firstName;
    private String lastName;
    private String email;
    private String phone;
    private String title;
    private int yearsOfExperience;
    private List<String> skills;
    private List<Object> experience;
    private List<Object> education;
    private List<String> experienceInsights;
    private List<String> educationInsights;
    private List<CategoryScore> categoryScores;
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\dto\CVSearchCriteriaDTO.java ===
// recruitpme/backend/cv-service/src/main/java/com/recruitpme/cvservice/dto/CVSearchCriteriaDTO.java
package com.recruitpme.cvservice.dto;

import lombok.Data;

import java.util.List;


@Data
public class CVSearchCriteriaDTO {
    private String keyword;
    private List<String> skills;
    private Integer minYearsExperience;
    private Integer maxYearsExperience;
    private Integer minScore;
    private Long jobId;
    private String status; // ANALYZED, QUALIFIED, REJECTED, etc.
    private int page;
    private int size;
    private String sortBy;
    private String sortDirection;
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\dto\CVUploadResponseDTO.java ===
package com.recruitpme.cvservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CVUploadResponseDTO {
    private List<String> fileIds;
    private int successCount;
    private int failureCount;
    private List<String> failedFiles;
    private String message;
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\dto\DashboardStatsDTO.java ===
package com.recruitpme.cvservice.dto;

import lombok.Data;


@Data
public class DashboardStatsDTO {
    private long analyzedCVs;
    private int analyzedCVsPercentChange;
    private long qualifiedCandidates;
    private int qualifiedCandidatesPercentChange;
    private int scheduledInterviews;
    private int scheduledInterviewsPercentChange;
    private int timeToHire;
    private int timeToHireChange;
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\dto\InterviewQuestionDTO.java ===
package com.recruitpme.cvservice.dto;

import lombok.Data;

@Data
public class InterviewQuestionDTO {
    private String question;
    private String rationale;
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\dto\InterviewQuestionRequestDTO.java ===
package com.recruitpme.cvservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class InterviewQuestionRequestDTO {
    private List<String> skills;
    private List<Object> experiences;
    private String jobDescription;
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\dto\JobDetailDTO.java ===
package com.recruitpme.cvservice.dto;

import lombok.Data;

import java.time.LocalDateTime;
import java.util.List;

@Data
public class JobDetailDTO {
    private Long id;
    private String title;
    private String description;
    private List<String> requiredSkills;
    private List<String> preferredSkills;
    private String location;
    private String jobType;
    private Integer minYearsExperience;
    private String salaryRange;
    private String department;
    private String jobDescription;
    private String status;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\dto\RecruitmentSourceDTO.java ===
package com.recruitpme.cvservice.dto;

import lombok.Data;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;

@Data

@NoArgsConstructor
public class RecruitmentSourceDTO {
    private long id;
    private String name;
    private int percentage;
    private String color;

    public RecruitmentSourceDTO(long id, String name, int percentage, String color) {
        this.id = id;
        this.name = name;
        this.percentage = percentage;
        this.color = color;
    }
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\dto\SkillAnalysisDTO.java ===
package com.recruitpme.cvservice.dto;

import lombok.Data;

@Data
public class SkillAnalysisDTO {
    private String name;
    private boolean matched;
    private int confidence;
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\entity\CVAnalysis.java ===
package com.recruitpme.cvservice.entity;

import lombok.Data;


import javax.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "cv_analysis")
@Data
public class CVAnalysis {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "cv_document_id")
    private CVDocument cvDocument;
    
    private Long jobId;
    
    private Integer score;
    
    @Column(columnDefinition = "TEXT")
    private String matchedSkills;
    
    @Column(columnDefinition = "TEXT")
    private String missingSkills;
    
    @Column(columnDefinition = "TEXT")
    private String strengths;
    
    @Column(columnDefinition = "TEXT")
    private String weaknesses;
    
    @Lob
    @Column(columnDefinition = "TEXT")
    private String analysisDetails;
    
    private LocalDateTime createdAt;
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\entity\CVDocument.java ===
package com.recruitpme.cvservice.entity;

import lombok.Data;

import javax.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "cv_document")
@Data
public class CVDocument {
    @Id
    private String id;

    private String filename;

    private String contentType;

    private Long size;

    private Long jobId;

    @Lob
    @Column(columnDefinition = "TEXT")
    private String content;

    private LocalDateTime uploadedAt;

    // Champs ajoutés
    private boolean inTalentPool = false;

    private LocalDateTime createdAt;

    // Ajout du champ manquant qui cause l'erreur
    private LocalDateTime addedToPoolAt;
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\entity\CVSkill.java ===
package com.recruitpme.cvservice.entity;

import lombok.Data;

import javax.persistence.*;

@Entity
@Table(name = "cv_skills")
@Data
public class CVSkill {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "cv_document_id")
    private CVDocument cvDocument;

    private String name;

    private int confidence;  // Niveau de confiance de la détection (0-100)

    private boolean isKeySkill;  // Indique si c'est une compétence clé

    private String category;  // Catégorie de compétence (technique, soft, etc.)
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\exception\FileStorageException.java ===
package com.recruitpme.cvservice.exception;

public class FileStorageException extends RuntimeException {
    public FileStorageException(String message) {
        super(message);
    }

    public FileStorageException(String message, Throwable cause) {
        super(message, cause);
    }
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\exception\GlobalExceptionHandler.java ===
// Exemple pour cv-service: recruitpme/backend/cv-service/src/main/java/com/recruitpme/cvservice/exception/GlobalExceptionHandler.java
package com.recruitpme.cvservice.exception;


import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Map<String, String>> handleResourceNotFoundException(ResourceNotFoundException ex) {
        log.error("Resource not found exception: {}", ex.getMessage());
        
        Map<String, String> response = new HashMap<>();
        response.put("message", ex.getMessage());
        response.put("status", "NOT_FOUND");
        
        return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
    }
    
    @ExceptionHandler(FileStorageException.class)
    public ResponseEntity<Map<String, String>> handleFileStorageException(FileStorageException ex) {
        log.error("File storage exception: {}", ex.getMessage());
        
        Map<String, String> response = new HashMap<>();
        response.put("message", ex.getMessage());
        response.put("status", "BAD_REQUEST");
        
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, Object>> handleValidationExceptions(MethodArgumentNotValidException ex) {
        log.error("Validation exception: {}", ex.getMessage());
        
        Map<String, Object> response = new HashMap<>();
        Map<String, String> errors = new HashMap<>();
        
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        
        response.put("message", "Validation failed");
        response.put("status", "BAD_REQUEST");
        response.put("errors", errors);
        
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, String>> handleGlobalException(Exception ex) {
        log.error("Unexpected exception: {}", ex.getMessage(), ex);
        
        Map<String, String> response = new HashMap<>();
        response.put("message", "An unexpected error occurred");
        response.put("status", "INTERNAL_SERVER_ERROR");
        
        return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\exception\ResourceNotFoundException.java ===
package com.recruitpme.cvservice.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;


@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\repository\CVAnalysisRepository.java ===
package com.recruitpme.cvservice.repository;

import com.recruitpme.cvservice.entity.CVAnalysis;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import org.springframework.data.domain.Pageable;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface CVAnalysisRepository extends JpaRepository<CVAnalysis, Long> {

    List<CVAnalysis> findByCvDocumentId(String cvDocumentId);

    // Ajouter à CVAnalysisRepository.java
    List<CVAnalysis> findTop10ByOrderByCreatedAtDesc(Pageable pageable);
    long countByCreatedAtAfter(LocalDateTime date);
    long countByCreatedAtBetween(LocalDateTime startDate, LocalDateTime endDate);

    Optional<CVAnalysis> findTopByCvDocumentIdOrderByCreatedAtDesc(String cvDocumentId);

    List<CVAnalysis> findByJobIdOrderByScoreDesc(Long jobId);

    long countByScoreGreaterThanEqualAndCreatedAtAfter(Integer score, LocalDateTime date);

    long countByScoreGreaterThanEqualAndCreatedAtBetween(Integer score, LocalDateTime startDate, LocalDateTime endDate);
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\repository\CVDocumentRepository.java ===
package com.recruitpme.cvservice.repository;

import com.recruitpme.cvservice.entity.CVAnalysis;
import com.recruitpme.cvservice.entity.CVDocument;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface CVDocumentRepository extends JpaRepository<CVDocument, String> {

    List<CVDocument> findByJobId(Long jobId);

    long countByUploadedAtAfter(LocalDateTime date);

    long countByUploadedAtBetween(LocalDateTime startDate, LocalDateTime endDate);
//    List<CVDocument> findTopByOrderByUploadedAtDesc(Pageable pageable);
//
//    List<CVDocument> findByUploadedAtAfterOrderByUploadedAtDesc(LocalDateTime date, Pageable pageable);

    // Ajouter à CVDocumentRepository.java
    List<CVDocument> findByInTalentPoolTrue(Pageable pageable);


    // Dans CVDocumentRepository :
    @Modifying
    @Transactional
    @Query("UPDATE CVDocument c SET c.inTalentPool = :inTalentPool WHERE c.id = :id")
    void updateInTalentPool(@Param("id") String id, @Param("inTalentPool") boolean inTalentPool);

    @Modifying
    @Transactional
    @Query("UPDATE CVDocument c SET c.addedToPoolAt = :addedToPoolAt WHERE c.id = :id")
    void updateAddedToPoolAt(@Param("id") String id, @Param("addedToPoolAt") LocalDateTime addedToPoolAt);
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\repository\CVSkillRepository.java ===
//package com.recruitpme.cvservice.repository;
//
//import com.recruitpme.cvservice.entity.CVSkill;
//import org.springframework.data.jpa.repository.JpaRepository;
//import org.springframework.stereotype.Repository;
//
//import java.util.List;
//
//@Repository
//public interface CVSkillRepository extends JpaRepository<CVSkill, Long> {
//
////    /**
////     * Trouve toutes les compétences associées à un CV spécifique
////     */
////    List<CVSkill> findByCvDocumentId(String cvDocumentId);
////
////    /**
////     * Supprime toutes les compétences associées à un CV spécifique
////     */
////    void deleteByCvDocumentId(String cvDocumentId);
////
////    /**
////     * Trouve les CV qui ont une compétence spécifique
////     */
////    List<CVSkill> findByNameContainingIgnoreCase(String skillName);
//
//    /**
//     * Compte le nombre de CV qui possèdent une compétence spécifique
//     */
//    long countByNameContainingIgnoreCase(String skillName);
//
//    /**
//     * Trouve les compétences les plus fréquentes
//     */
//    List<Object[]> findTopSkills(int limit);
//}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\service\CandidateServiceImpl.java ===
package com.recruitpme.cvservice.service;

import com.recruitpme.cvservice.dto.CandidateDTO;
import com.recruitpme.cvservice.dto.CandidateSearchCriteriaDTO;
import com.recruitpme.cvservice.entity.CVAnalysis;
import com.recruitpme.cvservice.entity.CVDocument;
import com.recruitpme.cvservice.exception.ResourceNotFoundException;
import com.recruitpme.cvservice.repository.CVAnalysisRepository;
import com.recruitpme.cvservice.repository.CVDocumentRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class CandidateServiceImpl implements CandidateService {

    private final CVDocumentRepository cvDocumentRepository;
    private final CVAnalysisRepository cvAnalysisRepository;

    @Override
    @Transactional(readOnly = true)
    public List<CandidateDTO> findCandidates(CandidateSearchCriteriaDTO criteria) {
        Pageable pageable = PageRequest.of(
                criteria.getPage(),
                criteria.getSize(),
                Sort.by(Sort.Direction.DESC, "uploadedAt")
        );

        List<CVDocument> documents;

        if (criteria.getStatus() != null && !criteria.getStatus().isEmpty()) {
            documents = cvDocumentRepository.findByStatusOrderByUploadedAtDesc(criteria.getStatus(), pageable);
        } else {
            documents = cvDocumentRepository.findAllByOrderByUploadedAtDesc(pageable);
        }

        List<CandidateDTO> candidates = new ArrayList<>();

        for (CVDocument doc : documents) {
            Optional<CVAnalysis> latestAnalysis = cvAnalysisRepository.findTopByCvDocumentIdOrderByCreatedAtDesc(doc.getId());

            if (latestAnalysis.isPresent()) {
                CVAnalysis analysis = latestAnalysis.get();

                // Filter by minimum score
                if (criteria.getMinScore() != null && analysis.getScore() < criteria.getMinScore()) {
                    continue;
                }

                // Filter by skills (if specified)
                if (criteria.getSkills() != null && !criteria.getSkills().isEmpty()) {
                    List<String> docSkills = Arrays.asList(doc.getSkills().split("\\|"));
                    if (!docSkills.containsAll(criteria.getSkills())) {
                        continue;
                    }
                }

                CandidateDTO candidate = convertToDTO(doc, analysis);
                candidates.add(candidate);
            } else {
                // Include documents without analysis only if no min score and no skills criteria
                if (criteria.getMinScore() == null && (criteria.getSkills() == null || criteria.getSkills().isEmpty())) {
                    CandidateDTO candidate = convertToDTO(doc, null);
                    candidates.add(candidate);
                }
            }
        }

        return candidates;
    }

    @Override
    @Transactional(readOnly = true)
    public List<CandidateDTO> findRecentCandidates(int limit) {
        Pageable pageable = PageRequest.of(0, limit, Sort.by(Sort.Direction.DESC, "uploadedAt"));
        List<CVDocument> documents = cvDocumentRepository.findAllByOrderByUploadedAtDesc(pageable);

        return documents.stream()
                .map(doc -> {
                    Optional<CVAnalysis> analysis = cvAnalysisRepository.findTopByCvDocumentIdOrderByCreatedAtDesc(doc.getId());
                    return convertToDTO(doc, analysis.orElse(null));
                })
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public CandidateDTO findById(String id) {
        CVDocument document = cvDocumentRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Candidate not found with id: " + id));

        Optional<CVAnalysis> analysis = cvAnalysisRepository.findTopByCvDocumentIdOrderByCreatedAtDesc(id);

        return convertToDTO(document, analysis.orElse(null));
    }

    private CandidateDTO convertToDTO(CVDocument document, CVAnalysis analysis) {
        CandidateDTO dto = new CandidateDTO();
        dto.setId(document.getId());
        dto.setFirstName(document.getFirstName());
        dto.setLastName(document.getLastName());
        dto.setEmail(document.getEmail());
        dto.setPhone(document.getPhone());
        dto.setTitle(document.getTitle());
        dto.setLocation(document.getLocation());

        if (document.getSkills() != null && !document.getSkills().isEmpty()) {
            dto.setSkills(Arrays.asList(document.getSkills().split("\\|")));
        } else {
            dto.setSkills(new ArrayList<>());
        }

        // Parse experience and education from document
        // Assuming the experience and education are stored in a structured format
        // This is a simplified implementation
        if (document.getExperience() != null && !document.getExperience().isEmpty()) {
            // Parse experience data based on your storage format
            // For this example, assuming a simple pipe-delimited format
            String[] experienceEntries = document.getExperience().split("\\|\\|");
            for (String entry : experienceEntries) {
                String[] parts = entry.split("\\|");
                if (parts.length >= 4) {
                    CandidateDTO.Experience exp = new CandidateDTO.Experience();
                    exp.setTitle(parts[0]);
                    exp.setCompany(parts[1]);
                    exp.setLocation(parts[2]);
                    exp.setPeriod(parts[3]);
                    if (parts.length > 4) {
                        exp.setDescription(parts[4]);
                    }
                    dto.getExperience().add(exp);
                }
            }
        }

        if (document.getEducation() != null && !document.getEducation().isEmpty()) {
            // Parse education data based on your storage format
            String[] educationEntries = document.getEducation().split("\\|\\|");
            for (String entry : educationEntries) {
                String[] parts = entry.split("\\|");
                if (parts.length >= 3) {
                    CandidateDTO.Education edu = new CandidateDTO.Education();
                    edu.setDegree(parts[0]);
                    edu.setInstitution(parts[1]);
                    edu.setPeriod(parts[2]);
                    dto.getEducation().add(edu);
                }
            }
        }

        dto.setCreatedAt(document.getUploadedAt());
        dto.setUpdatedAt(document.getUpdatedAt());

        // Add analysis data if available
        if (analysis != null) {
            dto.setScore(analysis.getScore());
            dto.setJobId(analysis.getJobId());
        } else {
            dto.setScore(0);
        }

        return dto;
    }
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\service\CVAnalysisService.java ===
package com.recruitpme.cvservice.service;

import com.recruitpme.cvservice.client.AIServiceClient;
import com.recruitpme.cvservice.client.JobServiceClient;
import com.recruitpme.cvservice.dto.*;
import com.recruitpme.cvservice.entity.CVAnalysis;
import com.recruitpme.cvservice.entity.CVDocument;
import com.recruitpme.cvservice.exception.ResourceNotFoundException;
import com.recruitpme.cvservice.repository.CVAnalysisRepository;
import com.recruitpme.cvservice.repository.CVDocumentRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.elasticsearch.index.query.QueryBuilders;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.elasticsearch.core.ElasticsearchOperations;
import org.springframework.data.elasticsearch.core.query.NativeSearchQueryBuilder;
import org.springframework.data.elasticsearch.core.query.Query;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class CVAnalysisService {

    private final CVDocumentRepository cvDocumentRepository;
    private final CVAnalysisRepository cvAnalysisRepository;
    private final AIServiceClient aiServiceClient;
    private final JobServiceClient jobServiceClient;
    private final ElasticsearchOperations elasticsearchOperations;

    // In-memory cache for tracking analysis progress
    private final Map<String, AnalysisProgress> analysisProgressMap = new ConcurrentHashMap<>();

    @Transactional
    public String startBatchAnalysis(List<String> cvIds, Long jobId) {
        // Generate a unique analysis ID
        String analysisId = UUID.randomUUID().toString();

        // Initialize progress tracking
        AnalysisProgress progress = new AnalysisProgress(cvIds.size());
        analysisProgressMap.put(analysisId, progress);

        // Fetch job details for analysis
        JobDetailDTO jobDetail = jobServiceClient.getJobDetail(jobId);

        // Start asynchronous processing
        processBatchAnalysis(analysisId, cvIds, jobDetail);

        return analysisId;
    }

    @Async
    protected void processBatchAnalysis(String analysisId, List<String> cvIds, JobDetailDTO jobDetail) {
        AnalysisProgress progress = analysisProgressMap.get(analysisId);

        // Process each CV asynchronously
        List<CompletableFuture<AnalysisResultDTO>> futures = cvIds.stream()
                .map(cvId -> CompletableFuture.supplyAsync(() -> {
                    try {
                        // Get CV content
                        CVDocument cvDocument = cvDocumentRepository.findById(cvId)
                                .orElseThrow(() -> new RuntimeException("CV not found: " + cvId));

                        // Call AI service for analysis
                        CVAnalysisRequestDTO request = new CVAnalysisRequestDTO(
                                cvDocument.getContent(),
                                jobDetail.getRequiredSkills(),
                                jobDetail.getPreferredSkills(),
                                jobDetail.getMinYearsExperience(),
                                jobDetail.getJobDescription()
                        );

                        CVAnalysisResponseDTO analysisResponse = aiServiceClient.analyzeCv(request);

                        // Save analysis results
                        CVAnalysis analysis = new CVAnalysis();
                        analysis.setCvDocument(cvDocument);
                        analysis.setJobId(jobDetail.getId());
                        analysis.setScore(analysisResponse.getScore());
                        analysis.setMatchedSkills(String.join(",", analysisResponse.getMatchedSkills()));
                        analysis.setMissingSkills(String.join(",", analysisResponse.getMissingSkills()));
                        analysis.setStrengths(String.join("\n", analysisResponse.getStrengths()));
                        analysis.setWeaknesses(String.join("\n", analysisResponse.getWeaknesses()));
                        analysis.setAnalysisDetails(analysisResponse.getDetailedAnalysis());
                        analysis.setCreatedAt(LocalDateTime.now());

                        cvAnalysisRepository.save(analysis);

                        // Create result DTO
                        AnalysisResultDTO result = new AnalysisResultDTO();
                        result.setId(cvDocument.getId());
                        result.setFirstName(analysisResponse.getFirstName());
                        result.setLastName(analysisResponse.getLastName());
                        result.setEmail(analysisResponse.getEmail());
                        result.setPhone(analysisResponse.getPhone());
                        result.setTitle(analysisResponse.getTitle());
                        result.setYearsOfExperience(analysisResponse.getYearsOfExperience());
                        result.setScore(analysisResponse.getScore());
                        result.setSkills(analysisResponse.getExtractedSkills());

                        // Update progress
                        progress.incrementProcessed();
                        progress.addResult(result);

                        return result;
                    } catch (Exception e) {
                        log.error("Error processing CV analysis for ID: {}", cvId, e);
                        progress.incrementProcessed();
                        return null;
                    }
                }))
                .collect(Collectors.toList());

        // Wait for all analyses to complete
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

        // Calculate analysis stats
        calculateAnalysisStats(analysisId);

        // Mark as completed
        progress.setCompleted(true);
    }

    private void calculateAnalysisStats(String analysisId) {
        AnalysisProgress progress = analysisProgressMap.get(analysisId);

        // Process skills
        Set<String> allSkills = new HashSet<>();
        progress.getResults().forEach(candidate -> {
            if (candidate != null && candidate.getSkills() != null) {
                allSkills.addAll(candidate.getSkills());
            }
        });

        // Count recommended candidates (score >= 85)
        long recommendedCandidates = progress.getResults().stream()
                .filter(candidate -> candidate != null && candidate.getScore() >= 85)
                .count();

        // Find top candidate
        Optional<AnalysisResultDTO> topCandidate = progress.getResults().stream()
                .filter(Objects::nonNull)
                .max(Comparator.comparing(AnalysisResultDTO::getScore));

        // Update stats in progress object
        AnalysisStatsDTO stats = new AnalysisStatsDTO();
        stats.setSkillsDetected(allSkills.size());
        stats.setRecommendedCandidates((int) recommendedCandidates);

        if (topCandidate.isPresent()) {
            AnalysisResultDTO top = topCandidate.get();
            stats.setTopCandidateName(top.getFirstName() + " " + top.getLastName());
            stats.setTopCandidateScore(top.getScore());
        }

        progress.setStats(stats);
    }

    @Transactional
    public AnalysisResultDTO analyzeSingleCV(String cvId, Long jobId) {
        // Fetch CV document
        CVDocument cvDocument = cvDocumentRepository.findById(cvId)
                .orElseThrow(() -> new RuntimeException("CV not found: " + cvId));

        // Fetch job details
        JobDetailDTO jobDetail = jobServiceClient.getJobDetail(jobId);

        // Prepare analysis request
        CVAnalysisRequestDTO request = new CVAnalysisRequestDTO(
                cvDocument.getContent(),
                jobDetail.getRequiredSkills(),
                jobDetail.getPreferredSkills(),
                jobDetail.getMinYearsExperience(),
                jobDetail.getJobDescription()
        );

        // Call AI service
        CVAnalysisResponseDTO analysisResponse = aiServiceClient.analyzeCv(request);

        // Save analysis results
        CVAnalysis analysis = new CVAnalysis();
        analysis.setCvDocument(cvDocument);
        analysis.setJobId(jobDetail.getId());
        analysis.setScore(analysisResponse.getScore());
        analysis.setMatchedSkills(String.join(",", analysisResponse.getMatchedSkills()));
        analysis.setMissingSkills(String.join(",", analysisResponse.getMissingSkills()));
        analysis.setStrengths(String.join("\n", analysisResponse.getStrengths()));
        analysis.setWeaknesses(String.join("\n", analysisResponse.getWeaknesses()));
        analysis.setAnalysisDetails(analysisResponse.getDetailedAnalysis());
        analysis.setCreatedAt(LocalDateTime.now());

        cvAnalysisRepository.save(analysis);

        // Create and return result
        AnalysisResultDTO result = new AnalysisResultDTO();
        result.setId(cvDocument.getId());
        result.setFirstName(analysisResponse.getFirstName());
        result.setLastName(analysisResponse.getLastName());
        result.setEmail(analysisResponse.getEmail());
        result.setPhone(analysisResponse.getPhone());
        result.setTitle(analysisResponse.getTitle());
        result.setYearsOfExperience(analysisResponse.getYearsOfExperience());
        result.setScore(analysisResponse.getScore());
        result.setSkills(analysisResponse.getExtractedSkills());

        return result;
    }

    public AnalysisProgressDTO getAnalysisProgress(String analysisId) {
        AnalysisProgress progress = analysisProgressMap.getOrDefault(
                analysisId,
                new AnalysisProgress(0)
        );

        AnalysisProgressDTO dto = new AnalysisProgressDTO();
        dto.setAnalysisId(analysisId);
        dto.setTotalDocuments(progress.getTotalDocuments());
        dto.setProcessedDocuments(progress.getProcessedDocuments());
        dto.setProgress(progress.calculateProgressPercentage());
        dto.setCompleted(progress.isCompleted());

        if (progress.isCompleted()) {
            dto.setResults(progress.getResults());
            dto.setStats(progress.getStats());
        }

        return dto;
    }

    @Transactional(readOnly = true)
    public CVDetailDTO getCVDetail(String id) {
        // Fetch CV document
        CVDocument cvDocument = cvDocumentRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("CV not found with id: " + id));

        // Fetch latest analysis if any
        Optional<CVAnalysis> latestAnalysis = cvAnalysisRepository.findTopByCvDocumentIdOrderByCreatedAtDesc(id);

        // Create DTO
        CVDetailDTO dto = new CVDetailDTO();
        dto.setId(cvDocument.getId());

        // If we have an analysis, use its extracted data
        if (latestAnalysis.isPresent()) {
            CVAnalysis analysis = latestAnalysis.get();

            // Fetch detailed information from AI service if needed
            CVDetailResponseDTO detailResponse = aiServiceClient.getCvDetailedInfo(cvDocument.getContent());

            // Basic information
            dto.setFirstName(detailResponse.getFirstName());
            dto.setLastName(detailResponse.getLastName());
            dto.setEmail(detailResponse.getEmail());
            dto.setPhone(detailResponse.getPhone());
            dto.setTitle(detailResponse.getTitle());
            dto.setYearsOfExperience(detailResponse.getYearsOfExperience());

            // Experience & Education
            dto.setExperience(detailResponse.getExperience());
            dto.setEducation(detailResponse.getEducation());

            // Skills and Analysis
            dto.setSkills(detailResponse.getSkills());
            dto.setScore(analysis.getScore());

            // Required and preferred skills analysis
            JobDetailDTO jobDetail = jobServiceClient.getJobDetail(analysis.getJobId());
            dto.setRequiredSkillsAnalysis(mapSkillsAnalysis(jobDetail.getRequiredSkills(), detailResponse.getSkills()));
            dto.setPreferredSkillsAnalysis(mapSkillsAnalysis(jobDetail.getPreferredSkills(), detailResponse.getSkills()));

            // Counters for UI
            dto.setRequiredSkillsMatch(countMatchedSkills(dto.getRequiredSkillsAnalysis()));
            dto.setRequiredSkillsTotal(dto.getRequiredSkillsAnalysis().size());
            dto.setPreferredSkillsMatch(countMatchedSkills(dto.getPreferredSkillsAnalysis()));
            dto.setPreferredSkillsTotal(dto.getPreferredSkillsAnalysis().size());

            // Insights
            dto.setStrengths(Arrays.asList(analysis.getStrengths().split("\n")));
            dto.setAreasForImprovement(Arrays.asList(analysis.getWeaknesses().split("\n")));
            dto.setJobFitAnalysis(analysis.getAnalysisDetails());
            dto.setExperienceInsights(detailResponse.getExperienceInsights());
            dto.setEducationInsights(detailResponse.getEducationInsights());

            // Category scores
            dto.setCategoryScores(detailResponse.getCategoryScores());

            // Interview questions
            InterviewQuestionRequestDTO questionRequest = new InterviewQuestionRequestDTO(
                    detailResponse.getSkills(),
                    detailResponse.getExperience(),
                    jobDetail.getJobDescription()
            );
            dto.setInterviewQuestions(aiServiceClient.generateInterviewQuestions(questionRequest));

            // Load notes
            dto.setNotes(getCandidateNotes(id));
        } else {
            // Basic placeholder if no analysis available
            dto.setFirstName("Candidat");
            dto.setLastName("Inconnu");
            dto.setTitle("Non analysé");
            dto.setSkills(Collections.emptyList());
            dto.setScore(0);
        }

        return dto;
    }

    /**
     * Récupère les candidats analysés récemment
     */
    @Transactional(readOnly = true)
    public List<AnalysisResultDTO> getRecentCandidates(int limit) {
        List<CVAnalysis> recentAnalyses = cvAnalysisRepository.findTop10ByOrderByCreatedAtDesc(PageRequest.of(0, limit));

        List<AnalysisResultDTO> results = new ArrayList<>();

        for (CVAnalysis analysis : recentAnalyses) {
            CVDocument cvDocument = analysis.getCvDocument();

            // Récupérer les informations détaillées via le service AI
            CVDetailResponseDTO detailResponse = aiServiceClient.getCvDetailedInfo(cvDocument.getContent());

            AnalysisResultDTO result = new AnalysisResultDTO();
            result.setId(cvDocument.getId());
            result.setFirstName(detailResponse.getFirstName());
            result.setLastName(detailResponse.getLastName());
            result.setEmail(detailResponse.getEmail());
            result.setPhone(detailResponse.getPhone());
            result.setTitle(detailResponse.getTitle());
            result.setYearsOfExperience(detailResponse.getYearsOfExperience());
            result.setScore(analysis.getScore());
            result.setSkills(detailResponse.getSkills());

            results.add(result);

            if (results.size() >= limit) {
                break;
            }
        }

        return results;
    }

    /**
     * Ajoute un candidat à la base de talents
     */
    @Transactional
    public void addToTalentPool(String cvId) {
        CVDocument cvDocument = cvDocumentRepository.findById(cvId)
                .orElseThrow(() -> new ResourceNotFoundException("CV not found with id: " + cvId));

        cvDocument.setInTalentPool(true);
        cvDocument.setAddedToPoolAt(LocalDateTime.now());

        cvDocumentRepository.save(cvDocument);
    }

    /**
     * Récupère les candidats de la base de talents
     */
    @Transactional(readOnly = true)
    public List<AnalysisResultDTO> getTalentPool(int page, int size, List<String> skills) {
        PageRequest pageRequest = PageRequest.of(page, size);

        List<CVDocument> talentPool;

        if (skills != null && !skills.isEmpty()) {
            // Recherche avec filtrage par compétences via Elasticsearch
            Query searchQuery = new NativeSearchQueryBuilder()
                    .withQuery(QueryBuilders.boolQuery()
                            .must(QueryBuilders.termQuery("inTalentPool", true))
                            .must(QueryBuilders.termsQuery("skills", skills)))
                    .withPageable(pageRequest)
                    .build();

            talentPool = elasticsearchOperations.search(searchQuery, CVDocument.class)
                    .getSearchHits().stream()
                    .map(hit -> hit.getContent())
                    .collect(Collectors.toList());
        } else {
            // Recherche simple de tous les candidats dans la base de talents
            talentPool = cvDocumentRepository.findByInTalentPoolTrue(pageRequest);
        }

        List<AnalysisResultDTO> results = new ArrayList<>();

        for (CVDocument cvDocument : talentPool) {
            // Récupérer la dernière analyse
            Optional<CVAnalysis> analysis = cvAnalysisRepository.findTopByCvDocumentIdOrderByCreatedAtDesc(cvDocument.getId());

            // Récupérer les informations détaillées
            CVDetailResponseDTO detailResponse = aiServiceClient.getCvDetailedInfo(cvDocument.getContent());

            AnalysisResultDTO result = new AnalysisResultDTO();
            result.setId(cvDocument.getId());
            result.setFirstName(detailResponse.getFirstName());
            result.setLastName(detailResponse.getLastName());
            result.setEmail(detailResponse.getEmail());
            result.setPhone(detailResponse.getPhone());
            result.setTitle(detailResponse.getTitle());
            result.setYearsOfExperience(detailResponse.getYearsOfExperience());
            result.setScore(analysis.map(CVAnalysis::getScore).orElse(0));
            result.setSkills(detailResponse.getSkills());

            results.add(result);
        }

        return results;
    }

    /**
     * Récupérer les statistiques du tableau de bord
     */
    @Transactional(readOnly = true)
    public DashboardStatsDTO getDashboardStats(String period) {
        LocalDateTime startDate;
        LocalDateTime now = LocalDateTime.now();

        // Déterminer la période
        switch (period) {
            case "7days":
                startDate = now.minusDays(7);
                break;
            case "30days":
                startDate = now.minusDays(30);
                break;
            case "90days":
                startDate = now.minusDays(90);
                break;
            case "year":
                startDate = now.minusYears(1);
                break;
            default:
                startDate = now.minusDays(30); // Par défaut, 30 jours
        }

        // Nombre de CV analysés
        long analyzedCVs = cvAnalysisRepository.countByCreatedAtAfter(startDate);

        // Récupérer le nombre de la période précédente pour calculer le pourcentage d'évolution
        LocalDateTime previousStartDate = startDate.minusDays(
                now.toLocalDate().toEpochDay() - startDate.toLocalDate().toEpochDay()
        );
        long previousAnalyzedCVs = cvAnalysisRepository.countByCreatedAtBetween(previousStartDate, startDate);

        int analyzedCVsPercentChange = previousAnalyzedCVs > 0
                ? (int) (((double) analyzedCVs / previousAnalyzedCVs - 1) * 100)
                : 100;

        // Candidats qualifiés (score >= 70)
        long qualifiedCandidates = cvAnalysisRepository.countByScoreGreaterThanEqualAndCreatedAtAfter(70, startDate);
        long previousQualifiedCandidates = cvAnalysisRepository.countByScoreGreaterThanEqualAndCreatedAtBetween(70, previousStartDate, startDate);

        int qualifiedCandidatesPercentChange = previousQualifiedCandidates > 0
                ? (int) (((double) qualifiedCandidates / previousQualifiedCandidates - 1) * 100)
                : 100;

        // Construire l'objet de statistiques
        DashboardStatsDTO stats = new DashboardStatsDTO();
        stats.setAnalyzedCVs(analyzedCVs);
        stats.setAnalyzedCVsPercentChange(analyzedCVsPercentChange);
        stats.setQualifiedCandidates(qualifiedCandidates);
        stats.setQualifiedCandidatesPercentChange(qualifiedCandidatesPercentChange);

        // Ajouter les statistiques supplémentaires (à implémenter selon votre logique métier)
        stats.setScheduledInterviews(0); // À récupérer via le service d'entretien
        stats.setScheduledInterviewsPercentChange(0);
        stats.setTimeToHire(25); // Exemple de valeur pour le temps moyen d'embauche
        stats.setTimeToHireChange(-2); // Exemple de changement

        return stats;
    }

    /**
     * Récupérer les sources de recrutement pour le tableau de bord
     */
    @Transactional(readOnly = true)
    public List<RecruitmentSourceDTO> getRecruitmentSources() {
        // Cette méthode devrait être implémentée selon votre logique métier
        // Exemple de données statiques pour démonstration
        List<RecruitmentSourceDTO> sources = new ArrayList<>();

        sources.add(new RecruitmentSourceDTO(1L, "LinkedIn", 35, "#4A6CF7"));
        sources.add(new RecruitmentSourceDTO(2L, "Indeed", 25, "#6AD2FF"));
        sources.add(new RecruitmentSourceDTO(3L, "Site web", 20, "#8E59FF"));
        sources.add(new RecruitmentSourceDTO(4L, "Recommandations", 12, "#FFA70B"));
        sources.add(new RecruitmentSourceDTO(5L, "Autres", 8, "#F78CA0"));

        return sources;
    }

    /**
     * Récupérer les notes associées à un candidat
     */
    private List<CandidateNoteDTO> getCandidateNotes(String candidateId) {
        // Cette méthode devrait être implémentée avec un appel à votre repository de notes
        // Exemple de données statiques pour démonstration
        List<CandidateNoteDTO> notes = new ArrayList<>();

        // Pour l'instant, retourner une liste vide
        return notes;
    }

    private List<SkillAnalysisDTO> mapSkillsAnalysis(List<String> jobSkills, List<String> candidateSkills) {
        return jobSkills.stream()
                .map(skill -> {
                    SkillAnalysisDTO analysis = new SkillAnalysisDTO();
                    analysis.setName(skill);

                    // Check if skill is matched
                    boolean matched = candidateSkills.stream()
                            .anyMatch(candidateSkill ->
                                    candidateSkill.equalsIgnoreCase(skill) ||
                                            candidateSkill.contains(skill) ||
                                            skill.contains(candidateSkill));

                    analysis.setMatched(matched);

                    // Simple confidence calculation, replace with AI-based confidence in real implementation
                    int confidence = matched ? 90 + new Random().nextInt(10) : 30 + new Random().nextInt(40);
                    analysis.setConfidence(confidence);

                    return analysis;
                })
                .collect(Collectors.toList());
    }

    private int countMatchedSkills(List<SkillAnalysisDTO> skillsAnalysis) {
        return (int) skillsAnalysis.stream()
                .filter(SkillAnalysisDTO::isMatched)
                .count();
    }

    // Inner class for tracking progress
    private static class AnalysisProgress {
        private final int totalDocuments;
        private int processedDocuments = 0;
        private boolean completed = false;
        private final List<AnalysisResultDTO> results = new ArrayList<>();
        private AnalysisStatsDTO stats = new AnalysisStatsDTO();

        public AnalysisProgress(int totalDocuments) {
            this.totalDocuments = totalDocuments;
        }

        public synchronized void incrementProcessed() {
            processedDocuments++;
        }

        public synchronized void addResult(AnalysisResultDTO result) {
            if (result != null) {
                results.add(result);
            }
        }

        public int calculateProgressPercentage() {
            if (totalDocuments == 0) return 100;
            return (processedDocuments * 100) / totalDocuments;
        }

        // Getters and setters
        public int getTotalDocuments() {
            return totalDocuments;
        }

        public int getProcessedDocuments() {
            return processedDocuments;
        }

        public boolean isCompleted() {
            return completed;
        }

        public void setCompleted(boolean completed) {
            this.completed = completed;
        }

        public List<AnalysisResultDTO> getResults() {
            return results;
        }

        public AnalysisStatsDTO getStats() {
            return stats;
        }

        public void setStats(AnalysisStatsDTO stats) {
            this.stats = stats;
        }
    }
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\service\CVStorageService.java ===
package com.recruitpme.cvservice.service;

import com.recruitpme.cvservice.config.StorageProperties;
import com.recruitpme.cvservice.entity.CVDocument;
import com.recruitpme.cvservice.repository.CVDocumentRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.tika.Tika;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.net.MalformedURLException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class CVStorageService {

    private final CVDocumentRepository cvDocumentRepository;
    private final StorageProperties storageProperties;
    private final Tika tika = new Tika();

    private Path getStorageLocation() {
        Path location = Paths.get(storageProperties.getLocation());
        try {
            Files.createDirectories(location);
            return location;
        } catch (IOException e) {
            throw new RuntimeException("Could not initialize storage location", e);
        }
    }

    @Transactional
    public List<String> storeFiles(List<MultipartFile> files, Long jobId) {
        List<String> storedFileIds = new ArrayList<>();

        for (MultipartFile file : files) {
            storedFileIds.add(storeFile(file, jobId));
        }

        return storedFileIds;
    }

    @Transactional
    public String storeFile(MultipartFile file, Long jobId) {
        String filename = StringUtils.cleanPath(file.getOriginalFilename());

        try {
            if (file.isEmpty()) {
                throw new RuntimeException("Failed to store empty file " + filename);
            }

            // Check if it's a valid CV file
            if (!isValidCVFile(file)) {
                throw new RuntimeException("Cannot store file with invalid format: " + filename);
            }

            // Generate a unique identifier
            String id = UUID.randomUUID().toString();

            // Store in filesystem
            Path storageLocation = getStorageLocation();
            Path targetPath = storageLocation.resolve(id + "_" + filename);
            Files.copy(file.getInputStream(), targetPath, StandardCopyOption.REPLACE_EXISTING);

            // Store metadata in database
            CVDocument document = new CVDocument();
            document.setId(id);
            document.setFilename(filename);
            document.setContentType(file.getContentType());
            document.setSize(file.getSize());
            document.setJobId(jobId);
            document.setContent(extractContent(file));
            document.setUploadedAt(LocalDateTime.now());

            cvDocumentRepository.save(document);

            return id;
        } catch (IOException e) {
            throw new RuntimeException("Failed to store file " + filename, e);
        }
    }

    private boolean isValidCVFile(MultipartFile file) throws IOException {
        // Get content type
        String contentType = tika.detect(file.getInputStream());

        // Accept PDF, DOC, DOCX, RTF, and TXT
        return contentType.equals("application/pdf") ||
                contentType.equals("application/msword") ||
                contentType.equals("application/vnd.openxmlformats-officedocument.wordprocessingml.document") ||
                contentType.equals("application/rtf") ||
                contentType.equals("text/plain");
    }

    private String extractContent(MultipartFile file) throws IOException {
        // TODO: Use Apache Tika to extract text content from different file types
        // This is a simplified placeholder
        return "Extracted content from " + file.getOriginalFilename();
    }

    public Resource loadFileAsResource(String id) {
        try {
            // Find document metadata
            CVDocument document = cvDocumentRepository.findById(id)
                    .orElseThrow(() -> new RuntimeException("File not found: " + id));

            // Load file from filesystem
            Path storageLocation = getStorageLocation();
            Path filePath = storageLocation.resolve(id + "_" + document.getFilename());
            Resource resource = new UrlResource(filePath.toUri());

            if (resource.exists()) {
                return resource;
            } else {
                throw new RuntimeException("File not found: " + id);
            }
        } catch (MalformedURLException e) {
            throw new RuntimeException("File not found: " + id, e);
        }
    }
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\service\DashboardService.java ===
package com.recruitpme.cvservice.service;

import com.recruitpme.cvservice.dto.DashboardStatsDTO;
import com.recruitpme.cvservice.dto.RecruitmentSourceDTO;


import java.util.List;

public interface DashboardService {
    DashboardStatsDTO getDashboardStats(String period);
    
    List<RecruitmentSourceDTO> getRecruitmentSources();
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\java\com\recruitpme\cvservice\service\DashboardServiceImpl.java ===
package com.recruitpme.cvservice.service;

import com.recruitpme.cvservice.dto.DashboardStatsDTO;
import com.recruitpme.cvservice.dto.RecruitmentSourceDTO;
import com.recruitpme.cvservice.repository.CVAnalysisRepository;
import com.recruitpme.cvservice.repository.CVDocumentRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;


import java.time.LocalDateTime;
import java.util.*;

@Service
@RequiredArgsConstructor
@Slf4j
public class DashboardServiceImpl implements DashboardService {

    private final CVDocumentRepository cvDocumentRepository;
    private final CVAnalysisRepository cvAnalysisRepository;

    @Override
    @Transactional(readOnly = true)
    public DashboardStatsDTO getDashboardStats(String period) {
        LocalDateTime startDate = calculateStartDate(period);
        
        // Get counts for each metric
        long analyzedCVs = cvDocumentRepository.countByUploadedAtAfter(startDate);
        
        // For previous period
        LocalDateTime previousPeriodStart = getStartDateForPreviousPeriod(period, startDate);
        long previousAnalyzedCVs = cvDocumentRepository.countByUploadedAtBetween(
                previousPeriodStart, startDate);
        
        // Calculate percentage changes
        int analyzedCVsPercentChange = calculatePercentChange(analyzedCVs, previousAnalyzedCVs);
        
        // Qualified candidates (score >= 80)
        long qualifiedCandidates = cvAnalysisRepository.countByScoreGreaterThanEqualAndCreatedAtAfter(80, startDate);
        long previousQualifiedCandidates = cvAnalysisRepository.countByScoreGreaterThanEqualAndCreatedAtBetween(
                80, previousPeriodStart, startDate);
        int qualifiedCandidatesPercentChange = calculatePercentChange(qualifiedCandidates, previousQualifiedCandidates);
        
        // Mocked data for demonstration
        int scheduledInterviews = 15;
        int scheduledInterviewsPercentChange = 25;
        int timeToHire = 21;
        int timeToHireChange = -2;
        
        DashboardStatsDTO stats = new DashboardStatsDTO();
        stats.setAnalyzedCVs((int) analyzedCVs);
        stats.setAnalyzedCVsPercentChange(analyzedCVsPercentChange);
        stats.setQualifiedCandidates((int) qualifiedCandidates);
        stats.setQualifiedCandidatesPercentChange(qualifiedCandidatesPercentChange);
        stats.setScheduledInterviews(scheduledInterviews);
        stats.setScheduledInterviewsPercentChange(scheduledInterviewsPercentChange);
        stats.setTimeToHire(timeToHire);
        stats.setTimeToHireChange(timeToHireChange);
        
        return stats;
    }

    @Override
    public List<RecruitmentSourceDTO> getRecruitmentSources() {
        // Mock data for recruitment sources
        List<RecruitmentSourceDTO> sources = new ArrayList<>();
        
        sources.add(createSourceData("LinkedIn", 45, "#4A6FDC"));
        sources.add(createSourceData("Indeed", 25, "#2164F3"));
        sources.add(createSourceData("Website", 15, "#12B7B3"));
        sources.add(createSourceData("Referrals", 10, "#7A56CF"));
        sources.add(createSourceData("Other", 5, "#F8C12C"));
        
        return sources;
    }

    private RecruitmentSourceDTO createSourceData(String name, int percentage, String color) {
        // Générer un ID numérique au lieu d'un UUID
        return new RecruitmentSourceDTO(new Random().nextLong(), name, percentage, color);
    }

    private LocalDateTime calculateStartDate(String period) {
        LocalDateTime now = LocalDateTime.now();
        
        return switch (period) {
            case "7days" -> now.minusDays(7);
            case "14days" -> now.minusDays(14);
            case "30days" -> now.minusDays(30);
            case "90days" -> now.minusDays(90);
            case "6months" -> now.minusMonths(6);
            case "1year" -> now.minusYears(1);
            default -> now.minusDays(30);
        };
    }
    
    private LocalDateTime getStartDateForPreviousPeriod(String period, LocalDateTime currentPeriodStart) {
        LocalDateTime now = LocalDateTime.now();
        
        return switch (period) {
            case "7days" -> currentPeriodStart.minusDays(7);
            case "14days" -> currentPeriodStart.minusDays(14);
            case "30days" -> currentPeriodStart.minusDays(30);
            case "90days" -> currentPeriodStart.minusDays(90);
            case "6months" -> currentPeriodStart.minusMonths(6);
            case "1year" -> currentPeriodStart.minusYears(1);
            default -> currentPeriodStart.minusDays(30);
        };
    }
    
    private int calculatePercentChange(long current, long previous) {
        if (previous == 0) {
            return current > 0 ? 100 : 0;
        }
        
        return (int) ((current - previous) * 100 / previous);
    }
}
=== FIN ===

=== Contenu de backend\cv-service\src\main\resources\application.properties ===
# Server configuration
server.port=8082
spring.application.name=cv-service

# Database configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/cv_db
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.datasource.driver-class-name=org.postgresql.Driver


# JPA configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# Storage configuration for CV files
storage.location=./uploads/cv-files

# Elasticsearch configuration
spring.elasticsearch.rest.uris=http://elasticsearch:9200

# MinIO configuration
minio.url=http://minio:9000
minio.access-key=minioadmin
minio.secret-key=minioadmin
minio.bucket-name=cv-documents

# Service URLs
services.ai-service.url=http://ai-service:8000
services.job-service.url=http://localhost:8083

# Multipart file configuration
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

# Redis caching
spring.redis.host=redis
spring.redis.port=6379
spring.cache.type=redis
spring.cache.redis.time-to-live=3600000

# Logging
logging.level.com.recruitpme.cvservice=DEBUG
=== FIN ===

=== Contenu de backend\interview-service\Dockerfile ===
FROM eclipse-temurin:17-jre
WORKDIR /app
COPY target/*.jar app.jar

EXPOSE 8084

ENTRYPOINT ["java", "-jar", "app.jar"]
=== FIN ===


=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\InterviewServiceApplication.java ===
package com.recruitpme.interviewservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;


@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients
public class InterviewServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(InterviewServiceApplication.class, args);
    }
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\client\AIServiceClient.java ===
package com.recruitpme.interviewservice.client;

import com.recruitpme.interviewservice.dto.InterviewQuestionDTO;
import com.recruitpme.interviewservice.dto.InterviewQuestionsRequestDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;


import java.util.List;

@FeignClient(name = "ai-service", url = "${services.ai-service.url}")
public interface AIServiceClient {

    @PostMapping("/api/generate-interview-questions")
    List<InterviewQuestionDTO> generateInterviewQuestions(@RequestBody InterviewQuestionsRequestDTO request);
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\client\CVServiceClient.java ===
package com.recruitpme.interviewservice.client;

import com.recruitpme.interviewservice.dto.CVDetailDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;


@FeignClient(name = "cv-service", url = "${services.cv-service.url}")
public interface CVServiceClient {

    @GetMapping("/api/cv/{id}")
    CVDetailDTO getCVDetail(@PathVariable("id") String id);
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\client\JobServiceClient.java ===
package com.recruitpme.interviewservice.client;

import com.recruitpme.interviewservice.dto.JobDetailDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;


@FeignClient(name = "job-service", url = "${services.job-service.url}")
public interface JobServiceClient {

    @GetMapping("/api/jobs/{id}")
    JobDetailDTO getJobDetail(@PathVariable("id") Long id);
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\config\CalendarConfig.java ===
package com.recruitpme.interviewservice.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;


@Configuration
public class CalendarConfig {

    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        return objectMapper;
    }
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\config\FeignConfig.java ===
package com.recruitpme.interviewservice.config;

import feign.RequestInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;


@Configuration
public class FeignConfig {

    @Bean
    public RequestInterceptor requestInterceptor() {
        return requestTemplate -> {
            ServletRequestAttributes attrs = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
            if (attrs != null) {
                String authHeader = attrs.getRequest().getHeader("Authorization");
                if (authHeader != null) {
                    requestTemplate.header("Authorization", authHeader);
                }
            }
        };
    }
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\controller\InterviewController.java ===
package com.recruitpme.interviewservice.controller;

import com.recruitpme.interviewservice.dto.*;
import com.recruitpme.interviewservice.service.InterviewService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;


import javax.validation.Valid;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/interviews")
@RequiredArgsConstructor
@Slf4j
public class InterviewController {

    private final InterviewService interviewService;

    @GetMapping
    public ResponseEntity<List<InterviewListDTO>> getInterviews(
            @RequestParam(value = "status", required = false) String status,
            @RequestParam(value = "from", required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate from,
            @RequestParam(value = "to", required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate to) {
        
        log.info("Fetching interviews with status: {}, from: {}, to: {}", status, from, to);
        List<InterviewListDTO> interviews = interviewService.getInterviews(status, from, to);
        return ResponseEntity.ok(interviews);
    }

    @GetMapping("/{id}")
    public ResponseEntity<InterviewDetailDTO> getInterviewDetail(@PathVariable Long id) {
        log.info("Fetching interview details for ID: {}", id);
        InterviewDetailDTO interview = interviewService.getInterviewDetail(id);
        return ResponseEntity.ok(interview);
    }

    @PostMapping
    public ResponseEntity<InterviewDetailDTO> scheduleInterview(@Valid @RequestBody InterviewCreateDTO interviewDto) {
        log.info("Scheduling interview for candidate ID: {}", interviewDto.getCandidateId());
        InterviewDetailDTO createdInterview = interviewService.scheduleInterview(interviewDto);
        return ResponseEntity.ok(createdInterview);
    }

    @PutMapping("/{id}")
    public ResponseEntity<InterviewDetailDTO> updateInterview(
            @PathVariable Long id,
            @Valid @RequestBody InterviewCreateDTO interviewDto) {
        
        log.info("Updating interview with ID: {}", id);
        InterviewDetailDTO updatedInterview = interviewService.updateInterview(id, interviewDto);
        return ResponseEntity.ok(updatedInterview);
    }

    @PostMapping("/{id}/cancel")
    public ResponseEntity<InterviewDetailDTO> cancelInterview(
            @PathVariable Long id,
            @RequestBody Map<String, String> cancelRequest) {
        
        String reason = cancelRequest.get("reason");
        log.info("Cancelling interview with ID: {}, reason: {}", id, reason);
        InterviewDetailDTO cancelledInterview = interviewService.cancelInterview(id, reason);
        return ResponseEntity.ok(cancelledInterview);
    }

    @GetMapping("/stats")
    public ResponseEntity<InterviewStatDTO> getInterviewStats(
            @RequestParam(value = "period", defaultValue = "30days") String period) {
        
        log.info("Fetching interview stats for period: {}", period);
        InterviewStatDTO stats = interviewService.getInterviewStats(period);
        return ResponseEntity.ok(stats);
    }

    @PostMapping("/{id}/feedback")
    public ResponseEntity<InterviewDetailDTO> addFeedback(
            @PathVariable Long id,
            @Valid @RequestBody InterviewFeedbackDTO feedbackDto) {
        
        log.info("Adding feedback for interview with ID: {}", id);
        InterviewDetailDTO updatedInterview = interviewService.addFeedback(id, feedbackDto);
        return ResponseEntity.ok(updatedInterview);
    }

    @PostMapping("/{id}/complete")
    public ResponseEntity<InterviewDetailDTO> completeInterview(
            @PathVariable Long id,
            @RequestBody Map<String, String> completeRequest) {
        
        String outcome = completeRequest.get("outcome");
        log.info("Completing interview with ID: {}, outcome: {}", id, outcome);
        InterviewDetailDTO completedInterview = interviewService.completeInterview(id, outcome);
        return ResponseEntity.ok(completedInterview);
    }

    @PostMapping("/generate-questions")
    public ResponseEntity<List<InterviewQuestionDTO>> generateInterviewQuestions(
            @RequestParam Long candidateId,
            @RequestParam Long jobId) {
        
        log.info("Generating interview questions for candidate ID: {} and job ID: {}", candidateId, jobId);
        List<InterviewQuestionDTO> questions = interviewService.generateInterviewQuestions(candidateId, jobId);
        return ResponseEntity.ok(questions);
    }
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\dto\CVDetailDTO.java ===
package com.recruitpme.interviewservice.dto;

import lombok.Data;

import java.time.LocalDateTime;
import java.util.List;


@Data
public class CVDetailDTO {
    private String id;
    private String firstName;
    private String lastName;
    private String email;
    private String phone;
    private String title;
    private int yearsOfExperience;
    private List<String> skills;
    private List<ExperienceDTO> experience;
    private List<EducationDTO> education;
    private int score;
    private String status;
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\dto\EducationDTO.java ===
package com.recruitpme.interviewservice.dto;

import lombok.Data;


@Data
public class EducationDTO {
    private String degree;
    private String institution;
    private String location;
    private String startYear;
    private String endYear;
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\dto\ExperienceDTO.java ===
package com.recruitpme.interviewservice.dto;

import lombok.Data;


@Data
public class ExperienceDTO {
    private String title;
    private String company;
    private String location;
    private String startDate;
    private String endDate;
    private String description;
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\dto\InterviewCreateDTO.java ===
package com.recruitpme.interviewservice.dto;

import lombok.Data;


import javax.validation.constraints.Min;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotEmpty;
import javax.validation.constraints.NotNull;
import java.time.LocalDateTime;
import java.util.List;

@Data
public class InterviewCreateDTO {
    @NotBlank(message = "L'ID du candidat est obligatoire")
    private String candidateId;
    
    private Long jobId;
    
    @NotBlank(message = "Le type d'entretien est obligatoire")
    private String interviewType; // VIDEO, PHONE, IN_PERSON
    
    @NotNull(message = "La date et l'heure sont obligatoires")
    private LocalDateTime scheduledTime;
    
    @NotNull(message = "La durée est obligatoire")
    @Min(value = 15, message = "La durée minimale est de 15 minutes")
    private Integer duration; // in minutes
    
    private String location;
    
    @NotEmpty(message = "Au moins un interviewer est obligatoire")
    private List<String> interviewers;
    
    private String notes;
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\dto\InterviewDetailDTO.java ===
package com.recruitpme.interviewservice.dto;

import lombok.Data;


import java.time.LocalDateTime;
import java.util.List;

@Data
public class InterviewDetailDTO {
    private Long id;
    private String candidateId;
    private Long jobId;
    private String candidateName;
    private String candidateEmail;
    private String candidatePhone;
    private String jobTitle;
    private String interviewType;
    private LocalDateTime scheduledTime;
    private Integer duration;
    private String location;
    private List<String> interviewers;
    private String notes;
    private String status;
    private String cancellationReason;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\dto\InterviewFeedbackDTO.java ===
// recruitpme/backend/interview-service/src/main/java/com/recruitpme/interviewservice/dto/InterviewFeedbackDTO.java
package com.recruitpme.interviewservice.dto;

import lombok.Data;


import javax.validation.constraints.Max;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import java.util.List;
import java.util.Map;

@Data
public class InterviewFeedbackDTO {
    @NotBlank(message = "L'interviewer est obligatoire")
    private String interviewer;
    
    @NotNull(message = "Le score technique est obligatoire")
    @Min(value = 1, message = "Le score minimum est 1")
    @Max(value = 5, message = "Le score maximum est 5")
    private Integer technicalScore;
    
    @NotNull(message = "Le score comportemental est obligatoire")
    @Min(value = 1, message = "Le score minimum est 1")
    @Max(value = 5, message = "Le score maximum est 5")
    private Integer behavioralScore;
    
    @NotNull(message = "La recommandation est obligatoire")
    private String recommendation; // HIRE, CONSIDER, REJECT
    
    @NotBlank(message = "Les commentaires sont obligatoires")
    private String comments;
    
    private List<Map<String, String>> skillFeedback; // Skill name and feedback
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\dto\InterviewListDTO.java ===
package com.recruitpme.interviewservice.dto;

import lombok.Data;

import java.time.LocalDateTime;


@Data
public class InterviewListDTO {
    private Long id;
    private String candidateId;
    private Long jobId;
    private String candidateName;
    private String jobTitle;
    private String interviewType;
    private LocalDateTime scheduledTime;
    private Integer duration;
    private String status;
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\dto\InterviewQuestionDTO.java ===
package com.recruitpme.interviewservice.dto;

import lombok.Data;


@Data
public class InterviewQuestionDTO {
    private String question;
    private String rationale;
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\dto\InterviewQuestionsRequestDTO.java ===
package com.recruitpme.interviewservice.dto;

import lombok.Data;
import java.util.List;


@Data
public class InterviewQuestionsRequestDTO {
    private List<String> skills;
    private List<Object> experiences;
    private String jobDescription;
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\dto\InterviewStatDTO.java ===
package com.recruitpme.interviewservice.dto;

import lombok.Data;


@Data
public class InterviewStatDTO {
    private int scheduledCount;
    private int completedCount;
    private int cancelledCount;
    private int hireRecommendations;
    private int considerRecommendations;
    private int rejectRecommendations;
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\dto\JobDetailDTO.java ===
package com.recruitpme.interviewservice.dto;

import lombok.Data;

import java.time.LocalDateTime;
import java.util.List;


@Data
public class JobDetailDTO {
    private Long id;
    private String title;
    private String description;
    private List<String> requiredSkills;
    private List<String> preferredSkills;
    private String location;
    private String jobType;
    private Integer minYearsExperience;
    private String salaryRange;
    private String department;
    private String status;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\entity\Interview.java ===
package com.recruitpme.interviewservice.entity;

import lombok.Data;

import javax.persistence.*;
import java.time.LocalDateTime;


@Entity
@Table(name = "interviews")
@Data
public class Interview {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String candidateId;
    
    private Long jobId;
    
    private String interviewType; // VIDEO, PHONE, IN_PERSON
    
    private LocalDateTime scheduledTime;
    
    private Integer duration; // in minutes
    
    private String location;
    
    @Column(columnDefinition = "TEXT")
    private String interviewers; // Comma-separated list of interviewer IDs
    
    @Column(columnDefinition = "TEXT")
    private String notes;
    
    private String status; // SCHEDULED, COMPLETED, CANCELLED, NO_SHOW
    
    @Column(columnDefinition = "TEXT")
    private String cancellationReason;
    
    private String outcome; // HIRED, REJECTED, PENDING

    private LocalDateTime completedAt;
    
    private LocalDateTime createdAt;
    
    private LocalDateTime updatedAt;
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\entity\InterviewFeedback.java ===
package com.recruitpme.interviewservice.entity;

import lombok.Data;

import javax.persistence.*;
import java.time.LocalDateTime;


@Entity
@Table(name = "interview_feedbacks")
@Data
public class InterviewFeedback {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "interview_id")
    private Interview interview;
    
    private String interviewer;
    
    private Integer technicalScore;
    
    private Integer behavioralScore;
    
    private String recommendation; // HIRE, CONSIDER, REJECT
    
    @Column(columnDefinition = "TEXT")
    private String comments;
    
    @Column(columnDefinition = "TEXT")
    private String skillFeedback; // JSON string of skill assessments
    
    private LocalDateTime createdAt;
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\entity\InterviewQuestion.java ===
package com.recruitpme.interviewservice.entity;

import lombok.Data;

import javax.persistence.*;


@Entity
@Table(name = "interview_questions")
@Data
public class InterviewQuestion {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "interview_id")
    private Interview interview;
    
    @Column(columnDefinition = "TEXT")
    private String question;
    
    @Column(columnDefinition = "TEXT")
    private String rationale;
    
    private String category; // TECHNICAL, BEHAVIORAL, JOB_SPECIFIC
    
    private Integer orderIndex;
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\exception\GlobalExceptionHandler.java ===
package com.recruitpme.interviewservice.exception;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;


import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Map<String, String>> handleResourceNotFoundException(ResourceNotFoundException ex) {
        log.error("Resource not found exception: {}", ex.getMessage());
        
        Map<String, String> response = new HashMap<>();
        response.put("message", ex.getMessage());
        response.put("status", "NOT_FOUND");
        
        return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, Object>> handleValidationExceptions(MethodArgumentNotValidException ex) {
        log.error("Validation exception: {}", ex.getMessage());
        
        Map<String, Object> response = new HashMap<>();
        Map<String, String> errors = new HashMap<>();
        
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        
        response.put("message", "Validation failed");
        response.put("status", "BAD_REQUEST");
        response.put("errors", errors);
        
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, String>> handleGlobalException(Exception ex) {
        log.error("Unexpected exception: {}", ex.getMessage(), ex);
        
        Map<String, String> response = new HashMap<>();
        response.put("message", "An unexpected error occurred");
        response.put("status", "INTERNAL_SERVER_ERROR");
        
        return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\exception\ResourceNotFoundException.java ===
package com.recruitpme.interviewservice.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;


@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\repository\InterviewFeedbackRepository.java ===
package com.recruitpme.interviewservice.repository;

import com.recruitpme.interviewservice.entity.InterviewFeedback;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;


@Repository
public interface InterviewFeedbackRepository extends JpaRepository<InterviewFeedback, Long> {
    List<InterviewFeedback> findByInterviewId(Long interviewId);
    
    long countByInterviewId(Long interviewId);
    
    long countByRecommendationAndCreatedAtAfter(String recommendation, LocalDateTime date);
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\repository\InterviewQuestionRepository.java ===
package com.recruitpme.interviewservice.repository;

import com.recruitpme.interviewservice.entity.InterviewQuestion;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;


@Repository
public interface InterviewQuestionRepository extends JpaRepository<InterviewQuestion, Long> {
    List<InterviewQuestion> findByInterviewIdOrderByOrderIndexAsc(Long interviewId);
    
    void deleteByInterviewId(Long interviewId);
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\repository\InterviewRepository.java ===
package com.recruitpme.interviewservice.repository;

import com.recruitpme.interviewservice.entity.Interview;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;


@Repository
public interface InterviewRepository extends JpaRepository<Interview, Long> {
    List<Interview> findByStatus(String status);
    
    List<Interview> findByScheduledTimeBetween(LocalDateTime start, LocalDateTime end);
    
    List<Interview> findByStatusAndScheduledTimeBetween(String status, LocalDateTime start, LocalDateTime end);
    
    long countByStatusAndScheduledTimeAfter(String status, LocalDateTime date);
    
    long countByStatusAndCompletedAtAfter(String status, LocalDateTime date);
    
    long countByStatusAndUpdatedAtAfter(String status, LocalDateTime date);
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\service\InterviewService.java ===
package com.recruitpme.interviewservice.service;

import com.recruitpme.interviewservice.dto.*;

import java.time.LocalDate;
import java.util.List;


public interface InterviewService {
    List<InterviewListDTO> getInterviews(String status, LocalDate from, LocalDate to);
    
    InterviewDetailDTO getInterviewDetail(Long id);
    
    InterviewDetailDTO scheduleInterview(InterviewCreateDTO interviewDto);
    
    InterviewDetailDTO updateInterview(Long id, InterviewCreateDTO interviewDto);
    
    InterviewDetailDTO cancelInterview(Long id, String reason);
    
    InterviewDetailDTO addFeedback(Long id, InterviewFeedbackDTO feedbackDto);
    
    InterviewDetailDTO completeInterview(Long id, String outcome);
    
    List<InterviewQuestionDTO> generateInterviewQuestions(Long candidateId, Long jobId);
    
    InterviewStatDTO getInterviewStats(String period);
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\java\com\recruitpme\interviewservice\service\InterviewServiceImpl.java ===
package com.recruitpme.interviewservice.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.recruitpme.interviewservice.client.AIServiceClient;
import com.recruitpme.interviewservice.client.CVServiceClient;
import com.recruitpme.interviewservice.client.JobServiceClient;
import com.recruitpme.interviewservice.dto.*;
import com.recruitpme.interviewservice.entity.Interview;
import com.recruitpme.interviewservice.entity.InterviewFeedback;
import com.recruitpme.interviewservice.exception.ResourceNotFoundException;
import com.recruitpme.interviewservice.repository.InterviewFeedbackRepository;
import com.recruitpme.interviewservice.repository.InterviewRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.ArrayList;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;
import java.util.ArrayList;


@Service
@RequiredArgsConstructor
@Slf4j
public class InterviewServiceImpl implements InterviewService {

    private final InterviewRepository interviewRepository;
    private final InterviewFeedbackRepository interviewFeedbackRepository;
    private final CVServiceClient cvServiceClient;
    private final JobServiceClient jobServiceClient;
    private final AIServiceClient aiServiceClient;
    private final ObjectMapper objectMapper;

    @Override
    @Transactional(readOnly = true)
    public List<InterviewListDTO> getInterviews(String status, LocalDate from, LocalDate to) {
        List<Interview> interviews;
        
        if (status != null && from != null && to != null) {
            interviews = interviewRepository.findByStatusAndScheduledTimeBetween(
                    status, 
                    from.atStartOfDay(), 
                    to.plusDays(1).atStartOfDay()
            );
        } else if (status != null) {
            interviews = interviewRepository.findByStatus(status);
        } else if (from != null && to != null) {
            interviews = interviewRepository.findByScheduledTimeBetween(
                    from.atStartOfDay(), 
                    to.plusDays(1).atStartOfDay()
            );
        } else {
            interviews = interviewRepository.findAll();
        }
        
        return interviews.stream()
                .map(this::convertToListDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public InterviewDetailDTO getInterviewDetail(Long id) {
        Interview interview = interviewRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Interview not found with id: " + id));
        
        return convertToDetailDTO(interview);
    }

    @Override
    @Transactional
    public InterviewDetailDTO scheduleInterview(InterviewCreateDTO interviewDto) {
        // Verify candidate exists
        CVDetailDTO candidate = cvServiceClient.getCVDetail(interviewDto.getCandidateId());
        
        // Verify job exists if jobId is provided
        if (interviewDto.getJobId() != null) {
            jobServiceClient.getJobDetail(interviewDto.getJobId());
        }
        
        Interview interview = new Interview();
        interview.setCandidateId(interviewDto.getCandidateId());
        interview.setJobId(interviewDto.getJobId());
        interview.setInterviewType(interviewDto.getInterviewType());
        interview.setScheduledTime(interviewDto.getScheduledTime());
        interview.setDuration(interviewDto.getDuration());
        interview.setLocation(interviewDto.getLocation());
        interview.setInterviewers(String.join(",", interviewDto.getInterviewers()));
        interview.setNotes(interviewDto.getNotes());
        interview.setStatus("SCHEDULED");
        interview.setCreatedAt(LocalDateTime.now());
        
        Interview savedInterview = interviewRepository.save(interview);
        
        // TODO: Send notification to candidate and interviewers
        
        return convertToDetailDTO(savedInterview);
    }

    @Override
    @Transactional
    public InterviewDetailDTO updateInterview(Long id, InterviewCreateDTO interviewDto) {
        Interview interview = interviewRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Interview not found with id: " + id));
        
        interview.setInterviewType(interviewDto.getInterviewType());
        interview.setScheduledTime(interviewDto.getScheduledTime());
        interview.setDuration(interviewDto.getDuration());
        interview.setLocation(interviewDto.getLocation());
        interview.setInterviewers(String.join(",", interviewDto.getInterviewers()));
        interview.setNotes(interviewDto.getNotes());
        interview.setUpdatedAt(LocalDateTime.now());
        
        Interview updatedInterview = interviewRepository.save(interview);
        
        // TODO: Send notification about updated interview
        
        return convertToDetailDTO(updatedInterview);
    }

    @Override
    @Transactional
    public InterviewDetailDTO cancelInterview(Long id, String reason) {
        Interview interview = interviewRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Interview not found with id: " + id));
        
        interview.setStatus("CANCELLED");
        interview.setCancellationReason(reason);
        interview.setUpdatedAt(LocalDateTime.now());
        
        Interview cancelledInterview = interviewRepository.save(interview);
        
        // TODO: Send notification about cancelled interview
        
        return convertToDetailDTO(cancelledInterview);
    }

   @Override
    public List<InterviewQuestionDTO> generateInterviewQuestions(Long candidateId, Long jobId) {
        // Get candidate skills and experience
        CVDetailDTO candidate = cvServiceClient.getCVDetail(candidateId.toString()); // Convertir Long en String
        
        // Get job description
        JobDetailDTO job = jobServiceClient.getJobDetail(jobId);
        
        // Create request object
        InterviewQuestionsRequestDTO request = new InterviewQuestionsRequestDTO();
        request.setSkills(candidate.getSkills());
        
        // Convertir la liste d'ExperienceDTO en liste d'Object
        List<Object> experienceObjects = new ArrayList<>(candidate.getExperience());
        request.setExperiences(experienceObjects);
        
        request.setJobDescription(job.getDescription());
        
        // Generate questions using AI service
        return aiServiceClient.generateInterviewQuestions(request);
    }

    private InterviewListDTO convertToListDTO(Interview interview) {
        InterviewListDTO dto = new InterviewListDTO();
        dto.setId(interview.getId());
        dto.setCandidateId(interview.getCandidateId());
        dto.setJobId(interview.getJobId());
        dto.setInterviewType(interview.getInterviewType());
        dto.setScheduledTime(interview.getScheduledTime());
        dto.setDuration(interview.getDuration());
        dto.setStatus(interview.getStatus());
        
        // Get candidate info
        try {
            CVDetailDTO candidate = cvServiceClient.getCVDetail(interview.getCandidateId());
            dto.setCandidateName(candidate.getFirstName() + " " + candidate.getLastName());
        } catch (Exception e) {
            log.error("Error fetching candidate details: {}", e.getMessage());
            dto.setCandidateName("Unknown");
        }
        
        // Get job info if available
        if (interview.getJobId() != null) {
            try {
                JobDetailDTO job = jobServiceClient.getJobDetail(interview.getJobId());
                dto.setJobTitle(job.getTitle());
            } catch (Exception e) {
                log.error("Error fetching job details: {}", e.getMessage());
                dto.setJobTitle("Unknown");
            }
        }
        
        return dto;
    }

    private InterviewDetailDTO convertToDetailDTO(Interview interview) {
        InterviewDetailDTO dto = new InterviewDetailDTO();
        dto.setId(interview.getId());
        dto.setCandidateId(interview.getCandidateId());
        dto.setJobId(interview.getJobId());
        dto.setInterviewType(interview.getInterviewType());
        dto.setScheduledTime(interview.getScheduledTime());
        dto.setDuration(interview.getDuration());
        dto.setLocation(interview.getLocation());
        
        // Convert interviewers from comma-separated string to List
        if (interview.getInterviewers() != null && !interview.getInterviewers().isEmpty()) {
            dto.setInterviewers(List.of(interview.getInterviewers().split(",")));
        } else {
            dto.setInterviewers(List.of());
        }
        
        dto.setNotes(interview.getNotes());
        dto.setStatus(interview.getStatus());
        dto.setCancellationReason(interview.getCancellationReason());
        dto.setCreatedAt(interview.getCreatedAt());
        dto.setUpdatedAt(interview.getUpdatedAt());
        
        // Get candidate info
        try {
            CVDetailDTO candidate = cvServiceClient.getCVDetail(interview.getCandidateId());
            dto.setCandidateName(candidate.getFirstName() + " " + candidate.getLastName());
            dto.setCandidateEmail(candidate.getEmail());
            dto.setCandidatePhone(candidate.getPhone());
        } catch (Exception e) {
            log.error("Error fetching candidate details: {}", e.getMessage());
            dto.setCandidateName("Unknown");
        }
        
        // Get job info if available
        if (interview.getJobId() != null) {
            try {
                JobDetailDTO job = jobServiceClient.getJobDetail(interview.getJobId());
                dto.setJobTitle(job.getTitle());
            } catch (Exception e) {
                log.error("Error fetching job details: {}", e.getMessage());
                dto.setJobTitle("Unknown");
            }
        }
        
        return dto;
    }
    
    @Override
    @Transactional
    public InterviewDetailDTO addFeedback(Long id, InterviewFeedbackDTO feedbackDto) {
        Interview interview = interviewRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Interview not found with id: " + id));
        
        InterviewFeedback feedback = new InterviewFeedback();
        feedback.setInterview(interview);
        feedback.setInterviewer(feedbackDto.getInterviewer());
        feedback.setTechnicalScore(feedbackDto.getTechnicalScore());
        feedback.setBehavioralScore(feedbackDto.getBehavioralScore());
        feedback.setRecommendation(feedbackDto.getRecommendation());
        feedback.setComments(feedbackDto.getComments());
        
        try {
            feedback.setSkillFeedback(objectMapper.writeValueAsString(feedbackDto.getSkillFeedback()));
        } catch (Exception e) {
            log.error("Error serializing skill feedback: {}", e.getMessage());
            feedback.setSkillFeedback("[]");
        }
        
        feedback.setCreatedAt(LocalDateTime.now());
        
        interviewFeedbackRepository.save(feedback);
        
        // Update interview status if all interviewers have provided feedback
        String[] interviewers = interview.getInterviewers().split(",");
        long feedbackCount = interviewFeedbackRepository.countByInterviewId(id);
        
        if (feedbackCount >= interviewers.length) {
            interview.setStatus("FEEDBACK_COMPLETE");
            interview.setUpdatedAt(LocalDateTime.now());
            interviewRepository.save(interview);
        }
        
        return convertToDetailDTO(interview);
    }

    @Override
    @Transactional
    public InterviewDetailDTO completeInterview(Long id, String outcome) {
        Interview interview = interviewRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Interview not found with id: " + id));
        
        interview.setStatus("COMPLETED");
        interview.setOutcome(outcome);
        interview.setCompletedAt(LocalDateTime.now());
        interview.setUpdatedAt(LocalDateTime.now());
        
        Interview completedInterview = interviewRepository.save(interview);
        
        // TODO: Notify candidate and hiring manager
        
        return convertToDetailDTO(completedInterview);
    }

    @Override
    public InterviewStatDTO getInterviewStats(String period) {
        LocalDateTime startDate = calculateStartDate(period);
        
        // Calculate stats
        long scheduledCount = interviewRepository.countByStatusAndScheduledTimeAfter("SCHEDULED", startDate);
        long completedCount = interviewRepository.countByStatusAndCompletedAtAfter("COMPLETED", startDate);
        long cancelledCount = interviewRepository.countByStatusAndUpdatedAtAfter("CANCELLED", startDate);
        
        // Get recommendation stats
        long hireRecommendations = interviewFeedbackRepository.countByRecommendationAndCreatedAtAfter("HIRE", startDate);
        long considerRecommendations = interviewFeedbackRepository.countByRecommendationAndCreatedAtAfter("CONSIDER", startDate);
        long rejectRecommendations = interviewFeedbackRepository.countByRecommendationAndCreatedAtAfter("REJECT", startDate);
        
        InterviewStatDTO stats = new InterviewStatDTO();
        stats.setScheduledCount((int) scheduledCount);
        stats.setCompletedCount((int) completedCount);
        stats.setCancelledCount((int) cancelledCount);
        stats.setHireRecommendations((int) hireRecommendations);
        stats.setConsiderRecommendations((int) considerRecommendations);
        stats.setRejectRecommendations((int) rejectRecommendations);
        
        return stats;
    }

    private LocalDateTime calculateStartDate(String period) {
        LocalDateTime now = LocalDateTime.now();
        
        return switch (period) {
            case "7days" -> now.minusDays(7);
            case "14days" -> now.minusDays(14);
            case "30days" -> now.minusDays(30);
            case "90days" -> now.minusDays(90);
            case "6months" -> now.minusMonths(6);
            case "1year" -> now.minusYears(1);
            default -> now.minusDays(30);
        };
    }
}
=== FIN ===

=== Contenu de backend\interview-service\src\main\resources\application.properties ===
# Server configuration
server.port=8084
spring.application.name=interview-service

# Database configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/interview_db
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.datasource.driver-class-name=org.postgresql.Driver


# JPA configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# Service URLs
services.cv-service.url=http://cv-service:8082
services.job-service.url=http://job-service:8083
services.ai-service.url=http://ai-service:8000
services.notification-service.url=http://notification-service:8085

# Logging
logging.level.com.recruitpme.interviewservice=DEBUG

=== FIN ===

=== Contenu de backend\job-service\Dockerfile ===
FROM eclipse-temurin:17-jre
WORKDIR /app
COPY target/*.jar app.jar

EXPOSE 8083

ENTRYPOINT ["java", "-jar", "app.jar"]
=== FIN ===


=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\JobServiceApplication.java ===
package com.recruitpme.jobservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;


@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients
public class JobServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(JobServiceApplication.class, args);
    }
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\client\AIServiceClient.java ===
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\config\ElasticsearchConfig.java ===
package com.recruitpme.jobservice.config;

import org.elasticsearch.client.RestHighLevelClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.elasticsearch.client.ClientConfiguration;
import org.springframework.data.elasticsearch.client.RestClients;
import org.springframework.data.elasticsearch.core.ElasticsearchOperations;
import org.springframework.data.elasticsearch.core.ElasticsearchRestTemplate;
import org.springframework.data.elasticsearch.repository.config.EnableElasticsearchRepositories;


@Configuration
@EnableElasticsearchRepositories(basePackages = "com.recruitpme.jobservice.repository")
public class ElasticsearchConfig {

    @Value("${spring.elasticsearch.rest.uris}")
    private String elasticsearchUri;

    @Bean
    public RestHighLevelClient client() {
        ClientConfiguration clientConfiguration = ClientConfiguration.builder()
                .connectedTo(elasticsearchUri.replace("http://", ""))
                .build();

        return RestClients.create(clientConfiguration).rest();
    }

    @Bean
    public ElasticsearchOperations elasticsearchTemplate() {
        return new ElasticsearchRestTemplate(client());
    }
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\config\FeignConfig.java ===
package com.recruitpme.jobservice.config;

import feign.RequestInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;


@Configuration
public class FeignConfig {

    @Bean
    public RequestInterceptor requestInterceptor() {
        return requestTemplate -> {
            ServletRequestAttributes attrs = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
            if (attrs != null) {
                String authHeader = attrs.getRequest().getHeader("Authorization");
                if (authHeader != null) {
                    requestTemplate.header("Authorization", authHeader);
                }
            }
        };
    }
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\controller\JobApplicationController.java ===
package com.recruitpme.jobservice.controller;

import com.recruitpme.jobservice.dto.JobApplicationDTO;
import com.recruitpme.jobservice.service.JobApplicationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;


import javax.validation.Valid;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/job-applications")
@RequiredArgsConstructor
@Slf4j
public class JobApplicationController {

    private final JobApplicationService jobApplicationService;

    @GetMapping("/job/{jobId}")
    public ResponseEntity<List<JobApplicationDTO>> getApplicationsByJob(@PathVariable Long jobId) {
        log.info("Fetching applications for job ID: {}", jobId);
        List<JobApplicationDTO> applications = jobApplicationService.getApplicationsByJob(jobId);
        return ResponseEntity.ok(applications);
    }

    @GetMapping("/candidate/{candidateId}")
    public ResponseEntity<List<JobApplicationDTO>> getApplicationsByCandidate(@PathVariable String candidateId) {
        log.info("Fetching applications for candidate ID: {}", candidateId);
        List<JobApplicationDTO> applications = jobApplicationService.getApplicationsByCandidate(candidateId);
        return ResponseEntity.ok(applications);
    }

    @GetMapping("/{id}")
    public ResponseEntity<JobApplicationDTO> getApplicationById(@PathVariable Long id) {
        log.info("Fetching application with ID: {}", id);
        JobApplicationDTO application = jobApplicationService.getApplicationById(id);
        return ResponseEntity.ok(application);
    }

    @PostMapping
    public ResponseEntity<JobApplicationDTO> createApplication(@Valid @RequestBody JobApplicationDTO applicationDto) {
        log.info("Creating application for job ID: {} and candidate ID: {}", 
                applicationDto.getJobId(), applicationDto.getCandidateId());
        JobApplicationDTO createdApplication = jobApplicationService.createApplication(applicationDto);
        return ResponseEntity.ok(createdApplication);
    }

    @PutMapping("/{id}/status")
    public ResponseEntity<JobApplicationDTO> updateApplicationStatus(
            @PathVariable Long id, 
            @RequestBody Map<String, String> statusUpdate) {
        
        String status = statusUpdate.get("status");
        log.info("Updating application status for ID: {} to {}", id, status);
        JobApplicationDTO updatedApplication = jobApplicationService.updateApplicationStatus(id, status);
        return ResponseEntity.ok(updatedApplication);
    }

    @PutMapping("/{id}/notes")
    public ResponseEntity<JobApplicationDTO> addApplicationNotes(
            @PathVariable Long id, 
            @RequestBody Map<String, String> notesUpdate) {
        
        String notes = notesUpdate.get("notes");
        log.info("Adding notes to application ID: {}", id);
        JobApplicationDTO updatedApplication = jobApplicationService.addApplicationNotes(id, notes);
        return ResponseEntity.ok(updatedApplication);
    }
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\controller\JobController.java ===
package com.recruitpme.jobservice.controller;

import com.recruitpme.jobservice.dto.JobCreateDTO;
import com.recruitpme.jobservice.dto.JobDetailDTO;
import com.recruitpme.jobservice.dto.JobListingDTO;
import com.recruitpme.jobservice.dto.JobSearchCriteriaDTO;
import com.recruitpme.jobservice.dto.JobStatsDTO;
import com.recruitpme.jobservice.service.JobService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;


import javax.validation.Valid;
import java.util.List;

@RestController
@RequestMapping("/api/jobs")
@RequiredArgsConstructor
@Slf4j
public class JobController {

    private final JobService jobService;

    @GetMapping
    public ResponseEntity<List<JobListingDTO>> getJobs(
            @RequestParam(value = "status", required = false) String status,
            @RequestParam(value = "page", defaultValue = "0") int page,
            @RequestParam(value = "size", defaultValue = "10") int size) {
        
        log.info("Fetching jobs with status: {}, page: {}, size: {}", status, page, size);
        List<JobListingDTO> jobs = jobService.getJobs(status, page, size);
        return ResponseEntity.ok(jobs);
    }

    @GetMapping("/active")
    public ResponseEntity<List<JobListingDTO>> getActiveJobs() {
        log.info("Fetching active jobs");
        List<JobListingDTO> jobs = jobService.getActiveJobs();
        return ResponseEntity.ok(jobs);
    }

    @GetMapping("/{id}")
    public ResponseEntity<JobDetailDTO> getJobDetail(@PathVariable Long id) {
        log.info("Fetching job details for ID: {}", id);
        JobDetailDTO job = jobService.getJobDetail(id);
        return ResponseEntity.ok(job);
    }

    @PostMapping
    public ResponseEntity<JobDetailDTO> createJob(@Valid @RequestBody JobCreateDTO jobDto) {
        log.info("Creating new job: {}", jobDto.getTitle());
        JobDetailDTO createdJob = jobService.createJob(jobDto);
        return ResponseEntity.ok(createdJob);
    }

    @PutMapping("/{id}")
    public ResponseEntity<JobDetailDTO> updateJob(
            @PathVariable Long id,
            @Valid @RequestBody JobCreateDTO jobDto) {
        
        log.info("Updating job with ID: {}", id);
        JobDetailDTO updatedJob = jobService.updateJob(id, jobDto);
        return ResponseEntity.ok(updatedJob);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteJob(@PathVariable Long id) {
        log.info("Deleting job with ID: {}", id);
        jobService.deleteJob(id);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/generate-description")
    public ResponseEntity<String> generateJobDescription(
            @RequestParam String title,
            @RequestParam List<String> requirements) {
        
        log.info("Generating job description for title: {}", title);
        String description = jobService.generateJobDescription(title, requirements);
        return ResponseEntity.ok(description);
    }
    
    @PostMapping("/search")
    public ResponseEntity<List<JobDetailDTO>> searchJobs(@RequestBody JobSearchCriteriaDTO criteria) {
        log.info("Searching jobs with criteria: {}", criteria);
        List<JobDetailDTO> jobs = jobService.searchJobs(criteria);
        return ResponseEntity.ok(jobs);

    }
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\controller\WorkflowController.java ===
package com.recruitpme.jobservice.controller;

import com.recruitpme.jobservice.dto.StageDTO;
import com.recruitpme.jobservice.dto.WorkflowDTO;
import com.recruitpme.jobservice.service.WorkflowService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.List;

@RestController
@RequestMapping("/api/workflows")
@RequiredArgsConstructor
@Slf4j
public class WorkflowController {

    private final WorkflowService workflowService;

    @GetMapping
    public ResponseEntity<List<WorkflowDTO>> getWorkflows() {
        log.info("Fetching all workflows");
        List<WorkflowDTO> workflows = workflowService.getAllWorkflows();
        return ResponseEntity.ok(workflows);
    }

    @GetMapping("/{id}")
    public ResponseEntity<WorkflowDTO> getWorkflowById(@PathVariable String id) {
        log.info("Fetching workflow with ID: {}", id);
        WorkflowDTO workflow = workflowService.getWorkflowById(id);
        return ResponseEntity.ok(workflow);
    }

    @GetMapping("/{id}/stages")
    public ResponseEntity<List<StageDTO>> getWorkflowStages(@PathVariable String id) {
        log.info("Fetching stages for workflow with ID: {}", id);
        List<StageDTO> stages = workflowService.getWorkflowStages(id);
        return ResponseEntity.ok(stages);
    }

    @PostMapping
    public ResponseEntity<WorkflowDTO> createWorkflow(@Valid @RequestBody WorkflowDTO workflowDTO) {
        log.info("Creating new workflow: {}", workflowDTO.getName());
        WorkflowDTO createdWorkflow = workflowService.createWorkflow(workflowDTO);
        return ResponseEntity.ok(createdWorkflow);
    }

    @PostMapping("/{id}/stages")
    public ResponseEntity<StageDTO> createWorkflowStage(
            @PathVariable String id,
            @Valid @RequestBody StageDTO stageDTO) {

        log.info("Creating new stage for workflow with ID: {}", id);
        StageDTO createdStage = workflowService.createWorkflowStage(id, stageDTO);
        return ResponseEntity.ok(createdStage);
    }

    @PutMapping("/{id}/stages/{stageId}")
    public ResponseEntity<StageDTO> updateWorkflowStage(
            @PathVariable String id,
            @PathVariable String stageId,
            @Valid @RequestBody StageDTO stageDTO) {

        log.info("Updating stage with ID: {} for workflow with ID: {}", stageId, id);
        StageDTO updatedStage = workflowService.updateWorkflowStage(id, stageId, stageDTO);
        return ResponseEntity.ok(updatedStage);
    }

    @DeleteMapping("/{id}/stages/{stageId}")
    public ResponseEntity<Void> deleteWorkflowStage(
            @PathVariable String id,
            @PathVariable String stageId) {

        log.info("Deleting stage with ID: {} from workflow with ID: {}", stageId, id);
        workflowService.deleteWorkflowStage(id, stageId);
        return ResponseEntity.noContent().build();
    }
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\dto\AIServiceClient.java ===
package com.recruitpme.jobservice.client;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.List;


@FeignClient(name = "ai-service", url = "${services.ai-service.url}")
public interface AIServiceClient {

    @PostMapping("/api/generate-job-description")
    String generateJobDescription(
            @RequestParam("title") String title, 
            @RequestParam("requirements") List<String> requirements
    );
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\dto\JobApplicationDTO.java ===
package com.recruitpme.jobservice.dto;

import lombok.Data;

import java.time.LocalDateTime;


@Data
public class JobApplicationDTO {
    private Long id;
    private Long jobId;
    private String jobTitle;
    private String candidateId;
    private String candidateName;
    private String status;
    private Integer score;
    private String notes;
    private LocalDateTime appliedAt;
    private LocalDateTime updatedAt;
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\dto\JobCreateDTO.java ===
package com.recruitpme.jobservice.dto;

import lombok.Data;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotEmpty;
import javax.validation.constraints.Size;
import java.util.List;


@Data
public class JobCreateDTO {
    @NotBlank(message = "Le titre est obligatoire")
    @Size(max = 255, message = "Le titre ne peut pas dépasser 255 caractères")
    private String title;
    
    @NotBlank(message = "La description est obligatoire")
    private String description;
    
    @NotEmpty(message = "Au moins une compétence requise est nécessaire")
    private List<String> requiredSkills;
    
    private List<String> preferredSkills;
    
    @NotBlank(message = "La localisation est obligatoire")
    private String location;
    
    @NotBlank(message = "Le type de contrat est obligatoire")
    private String jobType;
    
    @Min(value = 0, message = "L'expérience minimale ne peut pas être négative")
    private Integer minYearsExperience;
    
    private String salaryRange;
    
    private String department;
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\dto\JobDetailDTO.java ===
package com.recruitpme.jobservice.dto;

import lombok.Data;

import java.time.LocalDateTime;
import java.util.List;


@Data
public class JobDetailDTO {
    private Long id;
    private String title;
    private String description;
    private List<String> requiredSkills;
    private List<String> preferredSkills;
    private String location;
    private String jobType;
    private Integer minYearsExperience;
    private String salaryRange;
    private String department;
    private String status;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\dto\JobListingDTO.java ===
package com.recruitpme.jobservice.dto;

import lombok.Data;

import java.time.LocalDateTime;


@Data
public class JobListingDTO {
    private Long id;
    private String title;
    private String location;
    private String jobType;
    private String salaryRange;
    private String department;
    private String status;
    private LocalDateTime createdAt;
    private int applications;
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\dto\JobSearchCriteriaDTO.java ===
package com.recruitpme.jobservice.dto;

import lombok.Data;

import java.util.List;


@Data
public class JobSearchCriteriaDTO {
    private String keyword;
    private List<String> locations;
    private List<String> jobTypes;
    private String department;
    private Integer minYearsExperience;
    private Integer maxYearsExperience;
    private String status;
    private int page;
    private int size;
    private String sortBy;
    private String sortDirection;
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\dto\JobSkillDTO.java ===
package com.recruitpme.jobservice.dto;

import lombok.Data;


@Data
public class JobSkillDTO {
    private Long id;
    private String name;
    private boolean required;
    private int importance;
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\dto\JobStatsDTO.java ===
package com.recruitpme.jobservice.dto;

import lombok.Data;


@Data
public class JobStatsDTO {
    private int activeJobs;
    private int filledJobs;
    private int totalApplications;
    private int newApplications;
    private int candidatesInProcess;
    private double averageTimeToFill;
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\dto\StageDTO.java ===
package com.recruitpme.jobservice.dto;

import lombok.Data;

import javax.validation.constraints.NotBlank;
import java.time.LocalDateTime;

@Data
public class StageDTO {
    private String id;

    @NotBlank(message = "Stage name is required")
    private String name;

    @NotBlank(message = "Stage type is required")
    private String type;

    private String dueDate;
    private boolean visible = true;
    private int order;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\dto\WorkflowDTO.java ===
package com.recruitpme.jobservice.dto;

import lombok.Data;

import javax.validation.constraints.NotBlank;
import java.time.LocalDateTime;

@Data
public class WorkflowDTO {
    private String id;

    @NotBlank(message = "Workflow name is required")
    private String name;

    private int stageCount;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\entity\Job.java ===
package com.recruitpme.jobservice.entity;

import lombok.Data;


import javax.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "jobs")
@Data
public class Job {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String title;
    
    @Column(columnDefinition = "TEXT")
    private String description;
    
    @Column(columnDefinition = "TEXT")
    private String requirements;
    
    @Column(columnDefinition = "TEXT")
    private String preferredSkills;
    
    private String location;
    
    private String jobType; // FULL_TIME, PART_TIME, CONTRACT, etc.
    
    private Integer minYearsExperience;
    
    private String salaryRange;
    
    private String department;
    
    private String status; // ACTIVE, FILLED, DELETED, etc.
    
    private LocalDateTime createdAt;
    
    private LocalDateTime updatedAt;
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\entity\JobApplication.java ===
package com.recruitpme.jobservice.entity;

import lombok.Data;

import javax.persistence.*;
import java.time.LocalDateTime;


@Entity
@Table(name = "job_applications")
@Data
public class JobApplication {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "job_id")
    private Job job;
    
    private String candidateId;
    
    private String status; // APPLIED, SCREENING, INTERVIEW, OFFER, HIRED, REJECTED
    
    private Integer score;
    
    @Column(columnDefinition = "TEXT")
    private String notes;
    
    private LocalDateTime appliedAt;
    
    private LocalDateTime updatedAt;
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\entity\JobSkill.java ===
package com.recruitpme.jobservice.entity;

import lombok.Data;

import javax.persistence.*;


@Entity
@Table(name = "job_skills")
@Data
public class JobSkill {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "job_id")
    private Job job;
    
    private String name;
    
    private boolean required;
    
    private int importance; // 1-10 scale
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\exception\GlobalExceptionHandler.java ===
package com.recruitpme.jobservice.exception;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;


import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Map<String, String>> handleResourceNotFoundException(ResourceNotFoundException ex) {
        log.error("Resource not found exception: {}", ex.getMessage());
        
        Map<String, String> response = new HashMap<>();
        response.put("message", ex.getMessage());
        response.put("status", "NOT_FOUND");
        
        return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, Object>> handleValidationExceptions(MethodArgumentNotValidException ex) {
        log.error("Validation exception: {}", ex.getMessage());
        
        Map<String, Object> response = new HashMap<>();
        Map<String, String> errors = new HashMap<>();
        
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        
        response.put("message", "Validation failed");
        response.put("status", "BAD_REQUEST");
        response.put("errors", errors);
        
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }
    
    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<Map<String, String>> handleIllegalStateException(IllegalStateException ex) {
        log.error("Illegal state exception: {}", ex.getMessage());
        
        Map<String, String> response = new HashMap<>();
        response.put("message", ex.getMessage());
        response.put("status", "BAD_REQUEST");
        
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, String>> handleGlobalException(Exception ex) {
        log.error("Unexpected exception: {}", ex.getMessage(), ex);
        
        Map<String, String> response = new HashMap<>();
        response.put("message", "An unexpected error occurred");
        response.put("status", "INTERNAL_SERVER_ERROR");
        
        return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\exception\ResourceNotFoundException.java ===
package com.recruitpme.jobservice.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;


@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\repository\JobApplicationRepository.java ===
package com.recruitpme.jobservice.repository;

import com.recruitpme.jobservice.entity.JobApplication;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;


import java.util.List;

@Repository
public interface JobApplicationRepository extends JpaRepository<JobApplication, Long> {
    List<JobApplication> findByJobId(Long jobId);
    
    List<JobApplication> findByCandidateId(String candidateId);
    
    List<JobApplication> findByJobIdAndCandidateId(Long jobId, String candidateId);
    
    List<JobApplication> findByJobIdAndStatus(Long jobId, String status);
    
    long countByJobId(Long jobId);
    
    long countByJobIdAndStatus(Long jobId, String status);
    
    long countByStatusEquals(String status);
    
    long countByStatusIn(List<String> statuses);
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\repository\JobRepository.java ===
package com.recruitpme.jobservice.repository;

import com.recruitpme.jobservice.entity.Job;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;


import java.util.List;

@Repository
public interface JobRepository extends JpaRepository<Job, Long> {
    
    List<Job> findByStatusOrderByCreatedAtDesc(String status);
    
    List<Job> findByStatusOrderByCreatedAtDesc(String status, Pageable pageable);
    
    List<Job> findAllByOrderByCreatedAtDesc(Pageable pageable);
    
    long countByStatusEquals(String status);
    
    boolean existsByTitle(String title);
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\repository\JobSkillRepository.java ===
package com.recruitpme.jobservice.repository;

import com.recruitpme.jobservice.entity.JobSkill;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;


import java.util.List;

@Repository
public interface JobSkillRepository extends JpaRepository<JobSkill, Long> {
    List<JobSkill> findByJobId(Long jobId);
    
    List<JobSkill> findByJobIdAndRequired(Long jobId, boolean required);
    
    void deleteByJobId(Long jobId);
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\service\JobApplicationService.java ===
package com.recruitpme.jobservice.service;

import com.recruitpme.jobservice.dto.JobApplicationDTO;
import java.util.List;


public interface JobApplicationService {
    List<JobApplicationDTO> getApplicationsByJob(Long jobId);
    
    List<JobApplicationDTO> getApplicationsByCandidate(String candidateId);
    
    JobApplicationDTO getApplicationById(Long id);
    
    JobApplicationDTO createApplication(JobApplicationDTO applicationDto);
    
    JobApplicationDTO updateApplicationStatus(Long id, String status);
    
    JobApplicationDTO addApplicationNotes(Long id, String notes);
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\service\JobApplicationServiceImpl.java ===
package com.recruitpme.jobservice.service;

import com.recruitpme.jobservice.dto.JobApplicationDTO;
import com.recruitpme.jobservice.entity.Job;
import com.recruitpme.jobservice.entity.JobApplication;
import com.recruitpme.jobservice.exception.ResourceNotFoundException;
import com.recruitpme.jobservice.repository.JobApplicationRepository;
import com.recruitpme.jobservice.repository.JobRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;


import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class JobApplicationServiceImpl implements JobApplicationService {

    private final JobApplicationRepository jobApplicationRepository;
    private final JobRepository jobRepository;

    @Override
    @Transactional(readOnly = true)
    public List<JobApplicationDTO> getApplicationsByJob(Long jobId) {
        List<JobApplication> applications = jobApplicationRepository.findByJobId(jobId);
        
        return applications.stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<JobApplicationDTO> getApplicationsByCandidate(String candidateId) {
        List<JobApplication> applications = jobApplicationRepository.findByCandidateId(candidateId);
        
        return applications.stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public JobApplicationDTO getApplicationById(Long id) {
        JobApplication application = jobApplicationRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Application not found with id: " + id));
        
        return convertToDTO(application);
    }

    @Override
    @Transactional
    public JobApplicationDTO createApplication(JobApplicationDTO applicationDto) {
        // Verify job exists
        Job job = jobRepository.findById(applicationDto.getJobId())
                .orElseThrow(() -> new ResourceNotFoundException("Job not found with id: " + applicationDto.getJobId()));
        
        // Check if application already exists
        List<JobApplication> existingApplications = jobApplicationRepository.findByJobIdAndCandidateId(
                applicationDto.getJobId(), applicationDto.getCandidateId());
        
        if (!existingApplications.isEmpty()) {
            throw new IllegalStateException("Candidate has already applied for this job");
        }
        
        JobApplication application = new JobApplication();
        application.setJob(job);
        application.setCandidateId(applicationDto.getCandidateId());
        application.setStatus("APPLIED");
        application.setScore(applicationDto.getScore());
        application.setNotes(applicationDto.getNotes());
        application.setAppliedAt(LocalDateTime.now());
        
        JobApplication savedApplication = jobApplicationRepository.save(application);
        
        return convertToDTO(savedApplication);
    }

    @Override
    @Transactional
    public JobApplicationDTO updateApplicationStatus(Long id, String status) {
        JobApplication application = jobApplicationRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Application not found with id: " + id));
        
        application.setStatus(status);
        application.setUpdatedAt(LocalDateTime.now());
        
        // If status is HIRED, update job status to FILLED
        if ("HIRED".equals(status)) {
            Job job = application.getJob();
            job.setStatus("FILLED");
            job.setUpdatedAt(LocalDateTime.now());
            jobRepository.save(job);
        }
        
        JobApplication updatedApplication = jobApplicationRepository.save(application);
        
        return convertToDTO(updatedApplication);
    }

    @Override
    @Transactional
    public JobApplicationDTO addApplicationNotes(Long id, String notes) {
        JobApplication application = jobApplicationRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Application not found with id: " + id));
        
        application.setNotes(notes);
        application.setUpdatedAt(LocalDateTime.now());
        
        JobApplication updatedApplication = jobApplicationRepository.save(application);
        
        return convertToDTO(updatedApplication);
    }
    
    private JobApplicationDTO convertToDTO(JobApplication application) {
        JobApplicationDTO dto = new JobApplicationDTO();
        dto.setId(application.getId());
        dto.setJobId(application.getJob().getId());
        dto.setJobTitle(application.getJob().getTitle());
        dto.setCandidateId(application.getCandidateId());
        dto.setStatus(application.getStatus());
        dto.setScore(application.getScore());
        dto.setNotes(application.getNotes());
        dto.setAppliedAt(application.getAppliedAt());
        dto.setUpdatedAt(application.getUpdatedAt());
        
        return dto;
    }
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\service\JobService.java ===
package com.recruitpme.jobservice.service;

import com.recruitpme.jobservice.dto.*;

import java.util.List;


public interface JobService {
    List<JobListingDTO> getJobs(String status, int page, int size);
    
    List<JobListingDTO> getActiveJobs();
    
    JobDetailDTO getJobDetail(Long id);
    
    JobDetailDTO createJob(JobCreateDTO jobDto);
    
    JobDetailDTO updateJob(Long id, JobCreateDTO jobDto);
    
    void deleteJob(Long id);
    
    String generateJobDescription(String title, List<String> requirements);
    
    List<JobDetailDTO> searchJobs(JobSearchCriteriaDTO criteria);
    
    JobStatsDTO getJobStats();
}
=== FIN ===

=== Contenu de backend\job-service\src\main\java\com\recruitpme\jobservice\service\JobServiceImpl.java ===
package com.recruitpme.jobservice.service;

import com.recruitpme.jobservice.client.AIServiceClient;
import com.recruitpme.jobservice.dto.*;
import com.recruitpme.jobservice.entity.Job;
import com.recruitpme.jobservice.exception.ResourceNotFoundException;
import com.recruitpme.jobservice.repository.JobApplicationRepository;
import com.recruitpme.jobservice.repository.JobRepository;
import com.recruitpme.jobservice.repository.JobSkillRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.elasticsearch.index.query.QueryBuilders;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.elasticsearch.core.ElasticsearchOperations;
import org.springframework.data.elasticsearch.core.mapping.IndexCoordinates;
import org.springframework.data.elasticsearch.core.query.IndexQuery;
import org.springframework.data.elasticsearch.core.query.IndexQueryBuilder;
import org.springframework.data.elasticsearch.core.query.NativeSearchQueryBuilder;
import org.springframework.data.elasticsearch.core.query.Query;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;


import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class JobServiceImpl implements JobService {

    private final JobRepository jobRepository;
    private final JobSkillRepository jobSkillRepository;
    private final JobApplicationRepository jobApplicationRepository;
    private final ElasticsearchOperations elasticsearchOperations;
    private final AIServiceClient aiServiceClient;

    @Override
    @Transactional(readOnly = true)
    public List<JobListingDTO> getJobs(String status, int page, int size) {
        PageRequest pageRequest = PageRequest.of(page, size);
        
        List<Job> jobs;
        if (status != null && !status.isEmpty()) {
            jobs = jobRepository.findByStatusOrderByCreatedAtDesc(status, pageRequest);
        } else {
            jobs = jobRepository.findAllByOrderByCreatedAtDesc(pageRequest);
        }
        
        return jobs.stream()
                .map(this::convertToListingDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<JobListingDTO> getActiveJobs() {
        List<Job> jobs = jobRepository.findByStatusOrderByCreatedAtDesc("ACTIVE");
        
        return jobs.stream()
                .map(this::convertToListingDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public JobDetailDTO getJobDetail(Long id) {
        Job job = jobRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Job not found with id: " + id));
        
        return convertToDetailDTO(job);
    }

    @Override
    @Transactional
    public JobDetailDTO createJob(JobCreateDTO jobDto) {
        Job job = new Job();
        job.setTitle(jobDto.getTitle());
        job.setDescription(jobDto.getDescription());
        job.setRequirements(String.join("|", jobDto.getRequiredSkills()));
        job.setPreferredSkills(String.join("|", jobDto.getPreferredSkills()));
        job.setLocation(jobDto.getLocation());
        job.setJobType(jobDto.getJobType());
        job.setMinYearsExperience(jobDto.getMinYearsExperience());
        job.setSalaryRange(jobDto.getSalaryRange());
        job.setDepartment(jobDto.getDepartment());
        job.setStatus("ACTIVE");
        job.setCreatedAt(LocalDateTime.now());
        
        Job savedJob = jobRepository.save(job);
        
        // Index in Elasticsearch
        IndexQuery indexQuery = new IndexQueryBuilder()
                .withId(savedJob.getId().toString())
                .withObject(savedJob)
                .build();
        
        elasticsearchOperations.index(indexQuery, IndexCoordinates.of("jobs"));
        
        return convertToDetailDTO(savedJob);
    }

    @Override
    @Transactional
    public JobDetailDTO updateJob(Long id, JobCreateDTO jobDto) {
        Job job = jobRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Job not found with id: " + id));
        
        job.setTitle(jobDto.getTitle());
        job.setDescription(jobDto.getDescription());
        job.setRequirements(String.join("|", jobDto.getRequiredSkills()));
        job.setPreferredSkills(String.join("|", jobDto.getPreferredSkills()));
        job.setLocation(jobDto.getLocation());
        job.setJobType(jobDto.getJobType());
        job.setMinYearsExperience(jobDto.getMinYearsExperience());
        job.setSalaryRange(jobDto.getSalaryRange());
        job.setDepartment(jobDto.getDepartment());
        job.setUpdatedAt(LocalDateTime.now());
        
        Job updatedJob = jobRepository.save(job);
        
        // Update in Elasticsearch
        IndexQuery indexQuery = new IndexQueryBuilder()
                .withId(updatedJob.getId().toString())
                .withObject(updatedJob)
                .build();
        
        elasticsearchOperations.index(indexQuery, IndexCoordinates.of("jobs"));
        
        return convertToDetailDTO(updatedJob);
    }

    @Override
    @Transactional
    public void deleteJob(Long id) {
        Job job = jobRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Job not found with id: " + id));
        
        // Soft delete by changing status to DELETED
        job.setStatus("DELETED");
        job.setUpdatedAt(LocalDateTime.now());
        
        jobRepository.save(job);
        
        // Delete from Elasticsearch
        elasticsearchOperations.delete(id.toString(), IndexCoordinates.of("jobs"));
    }

    @Override
    public String generateJobDescription(String title, List<String> requirements) {
        // Call AI service to generate job description
        return aiServiceClient.generateJobDescription(title, requirements);
    }

    @Override
    public List<JobDetailDTO> searchJobs(JobSearchCriteriaDTO criteria) {
        // Create Elasticsearch query
        NativeSearchQueryBuilder searchQueryBuilder = new NativeSearchQueryBuilder();
        
        // Add keyword search if provided
        if (criteria.getKeyword() != null && !criteria.getKeyword().isEmpty()) {
            searchQueryBuilder.withQuery(
                QueryBuilders.multiMatchQuery(criteria.getKeyword(), 
                    "title", "description", "requirements", "preferredSkills")
            );
        }
        
        // Add filters
        if (criteria.getLocations() != null && !criteria.getLocations().isEmpty()) {
            searchQueryBuilder.withFilter(
                QueryBuilders.termsQuery("location", criteria.getLocations())
            );
        }
        
        if (criteria.getJobTypes() != null && !criteria.getJobTypes().isEmpty()) {
            searchQueryBuilder.withFilter(
                QueryBuilders.termsQuery("jobType", criteria.getJobTypes())
            );
        }
        
        if (criteria.getDepartment() != null && !criteria.getDepartment().isEmpty()) {
            searchQueryBuilder.withFilter(
                QueryBuilders.termQuery("department", criteria.getDepartment())
            );
        }
        
        if (criteria.getStatus() != null && !criteria.getStatus().isEmpty()) {
            searchQueryBuilder.withFilter(
                QueryBuilders.termQuery("status", criteria.getStatus())
            );
        }
        
        if (criteria.getMinYearsExperience() != null) {
            searchQueryBuilder.withFilter(
                QueryBuilders.rangeQuery("minYearsExperience")
                    .gte(criteria.getMinYearsExperience())
            );
        }
        
        // Execute search
        Query searchQuery = searchQueryBuilder.build();
        List<Job> searchResults = elasticsearchOperations
            .search(searchQuery, Job.class, IndexCoordinates.of("jobs"))
            .getSearchHits()
            .stream()
            .map(hit -> hit.getContent())
            .collect(Collectors.toList());
        
        // Convert to DTOs
        return searchResults.stream()
            .map(this::convertToDetailDTO)
            .collect(Collectors.toList());
    }

    @Override
    public JobStatsDTO getJobStats() {
        JobStatsDTO stats = new JobStatsDTO();
        
        // Count active and filled jobs
        long activeJobs = jobRepository.countByStatusEquals("ACTIVE");
        long filledJobs = jobRepository.countByStatusEquals("FILLED");
        
        // Count applications
        long totalApplications = jobApplicationRepository.count();
        long newApplications = jobApplicationRepository.countByStatusEquals("APPLIED");
        long inProcessApplications = jobApplicationRepository.countByStatusIn(
            List.of("SCREENING", "INTERVIEW", "OFFER")
        );
        
        // Calculate average time to fill (mock data for now)
        double averageTimeToFill = 25.5; // In days
        
        stats.setActiveJobs((int) activeJobs);
        stats.setFilledJobs((int) filledJobs);
        stats.setTotalApplications((int) totalApplications);
        stats.setNewApplications((int) newApplications);
        stats.setCandidatesInProcess((int) inProcessApplications);
        stats.setAverageTimeToFill(averageTimeToFill);
        
        return stats;
    }

    private JobListingDTO convertToListingDTO(Job job) {
        JobListingDTO dto = new JobListingDTO();
        dto.setId(job.getId());
        dto.setTitle(job.getTitle());
        dto.setLocation(job.getLocation());
        dto.setJobType(job.getJobType());
        dto.setSalaryRange(job.getSalaryRange());
        dto.setDepartment(job.getDepartment());
        dto.setStatus(job.getStatus());
        dto.setCreatedAt(job.getCreatedAt());
        
        // Get application count
        long applications = jobApplicationRepository.countByJobId(job.getId());
        dto.setApplications((int) applications);
        
        return dto;
    }

    private JobDetailDTO convertToDetailDTO(Job job) {
        JobDetailDTO dto = new JobDetailDTO();
        dto.setId(job.getId());
        dto.setTitle(job.getTitle());
        dto.setDescription(job.getDescription());
        dto.setRequiredSkills(job.getRequirements() != null ? 
                List.of(job.getRequirements().split("\\|")) : 
                List.of());
        dto.setPreferredSkills(job.getPreferredSkills() != null ? 
                List.of(job.getPreferredSkills().split("\\|")) : 
                List.of());
        dto.setLocation(job.getLocation());
        dto.setJobType(job.getJobType());
        dto.setMinYearsExperience(job.getMinYearsExperience());
        dto.setSalaryRange(job.getSalaryRange());
        dto.setDepartment(job.getDepartment());
        dto.setStatus(job.getStatus());
        dto.setCreatedAt(job.getCreatedAt());
        dto.setUpdatedAt(job.getUpdatedAt());
        
        return dto;
    }
}
=== FIN ===

=== Contenu de backend\job-service\src\main\resources\application.properties ===
# Server configuration
server.port=8083
spring.application.name=job-service

# Database configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/job_db
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.datasource.driver-class-name=org.postgresql.Driver


# JPA configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# Elasticsearch configuration
spring.elasticsearch.rest.uris=http://elasticsearch:9200

# Service URLs
services.ai-service.url=http://ai-service:8000

# Logging
logging.level.com.recruitpme.jobservice=DEBUG
=== FIN ===

=== Contenu de backend\notification-service\Dockerfile ===
FROM eclipse-temurin:17-jre
WORKDIR /app
COPY target/*.jar app.jar
EXPOSE 8085

ENTRYPOINT ["java", "-jar", "app.jar"]
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\NotificationServiceApplication.java ===
package com.recruitpme.notificationservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;


@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients
public class NotificationServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(NotificationServiceApplication.class, args);
    }
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\config\EmailConfig.java ===
package com.recruitpme.notificationservice.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.JavaMailSenderImpl;
import org.thymeleaf.spring5.SpringTemplateEngine;
import org.thymeleaf.templateresolver.ClassLoaderTemplateResolver;
import org.thymeleaf.templateresolver.ITemplateResolver;


import java.util.Properties;

@Configuration
public class EmailConfig {

    @Value("${mail.host}")
    private String host;

    @Value("${mail.port}")
    private int port;

    @Value("${mail.username}")
    private String username;

    @Value("${mail.password}")
    private String password;

    @Bean
    public JavaMailSender javaMailSender() {
        JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
        mailSender.setHost(host);
        mailSender.setPort(port);
        mailSender.setUsername(username);
        mailSender.setPassword(password);

        Properties props = mailSender.getJavaMailProperties();
        props.put("mail.transport.protocol", "smtp");
        props.put("mail.smtp.auth", "true");
        props.put("mail.smtp.starttls.enable", "true");
        props.put("mail.debug", "false");

        return mailSender;
    }
    
    @Bean
    @Primary  // Ajoutez cette annotation
    public ITemplateResolver thymeleafTemplateResolver() {
        ClassLoaderTemplateResolver templateResolver = new ClassLoaderTemplateResolver();
        templateResolver.setPrefix("templates/mail/");
        templateResolver.setSuffix(".html");
        templateResolver.setTemplateMode("HTML");
        templateResolver.setCharacterEncoding("UTF-8");
        return templateResolver;
    }
    
    @Bean
    public SpringTemplateEngine thymeleafTemplateEngine(ITemplateResolver templateResolver) {
        SpringTemplateEngine templateEngine = new SpringTemplateEngine();
        templateEngine.setTemplateResolver(templateResolver);
        return templateEngine;
    }
    
    @Bean
    public String fromEmail() {
        return username;
    }
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\controller\EmailTemplateController.java ===
package com.recruitpme.notificationservice.controller;

import com.recruitpme.notificationservice.dto.EmailTemplateDTO;
import com.recruitpme.notificationservice.service.EmailTemplateService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.List;


@RestController
@RequestMapping("/api/email-templates")
@RequiredArgsConstructor
@Slf4j
public class EmailTemplateController {

    private final EmailTemplateService emailTemplateService;

    @GetMapping
    public ResponseEntity<List<EmailTemplateDTO>> getAllTemplates() {
        log.info("Fetching all email templates");
        List<EmailTemplateDTO> templates = emailTemplateService.getAllTemplates();
        return ResponseEntity.ok(templates);
    }

    @GetMapping("/{id}")
    public ResponseEntity<EmailTemplateDTO> getTemplateById(@PathVariable Long id) {
        log.info("Fetching email template with ID: {}", id);
        EmailTemplateDTO template = emailTemplateService.getTemplateById(id);
        return ResponseEntity.ok(template);
    }

    @GetMapping("/code/{code}")
    public ResponseEntity<EmailTemplateDTO> getTemplateByCode(@PathVariable String code) {
        log.info("Fetching email template with code: {}", code);
        EmailTemplateDTO template = emailTemplateService.getTemplateByCode(code);
        return ResponseEntity.ok(template);
    }

    @PostMapping
    public ResponseEntity<EmailTemplateDTO> createTemplate(@Valid @RequestBody EmailTemplateDTO templateDto) {
        log.info("Creating email template with code: {}", templateDto.getCode());
        EmailTemplateDTO createdTemplate = emailTemplateService.createTemplate(templateDto);
        return ResponseEntity.ok(createdTemplate);
    }

    @PutMapping("/{id}")
    public ResponseEntity<EmailTemplateDTO> updateTemplate(
            @PathVariable Long id,
            @Valid @RequestBody EmailTemplateDTO templateDto) {
        
        log.info("Updating email template with ID: {}", id);
        EmailTemplateDTO updatedTemplate = emailTemplateService.updateTemplate(id, templateDto);
        return ResponseEntity.ok(updatedTemplate);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteTemplate(@PathVariable Long id) {
        log.info("Deleting email template with ID: {}", id);
        emailTemplateService.deleteTemplate(id);
        return ResponseEntity.noContent().build();
    }
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\controller\MessageController.java ===
package com.recruitpme.notificationservice.controller;

import com.recruitpme.notificationservice.dto.ConversationDTO;
import com.recruitpme.notificationservice.dto.MessageDTO;
import com.recruitpme.notificationservice.service.MessageService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/messages")
@RequiredArgsConstructor
@Slf4j
public class MessageController {

    private final MessageService messageService;

    @GetMapping("/conversations")
    public ResponseEntity<List<ConversationDTO>> getConversations(
            @RequestParam(required = false) String filter) {

        log.info("Fetching conversations with filter: {}", filter);
        List<ConversationDTO> conversations = messageService.getConversations(filter);
        return ResponseEntity.ok(conversations);
    }

    @GetMapping("/conversations/{id}")
    public ResponseEntity<List<MessageDTO>> getConversationMessages(@PathVariable Long id) {
        log.info("Fetching messages for conversation with ID: {}", id);
        List<MessageDTO> messages = messageService.getConversationMessages(id);
        return ResponseEntity.ok(messages);
    }

    @PostMapping("/conversations/{id}")
    public ResponseEntity<MessageDTO> sendMessage(
            @PathVariable Long id,
            @RequestBody Map<String, String> request) {

        String content = request.get("content");
        log.info("Sending message to conversation with ID: {}", id);
        MessageDTO message = messageService.sendMessage(id, content);
        return ResponseEntity.ok(message);
    }

    @PostMapping("/conversations/create")
    public ResponseEntity<ConversationDTO> createConversation(
            @RequestBody Map<String, Object> request) {

        String candidateId = (String) request.get("candidateId");
        String firstMessage = (String) request.get("message");
        log.info("Creating new conversation with candidate ID: {}", candidateId);
        ConversationDTO conversation = messageService.createConversation(candidateId, firstMessage);
        return ResponseEntity.ok(conversation);
    }
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\controller\MessageTemplateController.java ===
package com.recruitpme.notificationservice.controller;

import com.recruitpme.notificationservice.dto.MessageTemplateDTO;
import com.recruitpme.notificationservice.service.MessageTemplateService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.Map;

@RestController
@RequestMapping("/api/message-templates")
@RequiredArgsConstructor
@Slf4j
public class MessageTemplateController {

    private final MessageTemplateService messageTemplateService;

    @GetMapping
    public ResponseEntity<Map<String, Object>> getAllTemplates() {
        log.info("Récupération de tous les templates de messages");
        Map<String, Object> templates = messageTemplateService.getAllTemplates();
        return ResponseEntity.ok(templates);
    }

    @GetMapping("/{id}")
    public ResponseEntity<MessageTemplateDTO> getTemplateById(@PathVariable String id) {
        log.info("Récupération du template de message avec ID: {}", id);
        MessageTemplateDTO template = messageTemplateService.getTemplateById(id);
        return ResponseEntity.ok(template);
    }

    @PostMapping
    public ResponseEntity<MessageTemplateDTO> createTemplate(@Valid @RequestBody MessageTemplateDTO templateDTO) {
        log.info("Création d'un nouveau template de message: {}", templateDTO.getName());
        MessageTemplateDTO createdTemplate = messageTemplateService.createTemplate(templateDTO);
        return ResponseEntity.ok(createdTemplate);
    }

    @PutMapping("/{id}")
    public ResponseEntity<MessageTemplateDTO> updateTemplate(
            @PathVariable String id,
            @Valid @RequestBody MessageTemplateDTO templateDTO) {

        log.info("Mise à jour du template de message avec ID: {}", id);
        MessageTemplateDTO updatedTemplate = messageTemplateService.updateTemplate(id, templateDTO);
        return ResponseEntity.ok(updatedTemplate);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteTemplate(@PathVariable String id) {
        log.info("Suppression du template de message avec ID: {}", id);
        messageTemplateService.deleteTemplate(id);
        return ResponseEntity.noContent().build();
    }
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\controller\NotificationController.java ===
package com.recruitpme.notificationservice.controller;

import com.recruitpme.notificationservice.dto.NotificationCountDTO;
import com.recruitpme.notificationservice.dto.NotificationCreateDTO;
import com.recruitpme.notificationservice.dto.NotificationDTO;
import com.recruitpme.notificationservice.service.NotificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;


import javax.validation.Valid;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/notifications")
@RequiredArgsConstructor
@Slf4j
public class NotificationController {

    private final NotificationService notificationService;

    @GetMapping("/user/{userId}")
    public ResponseEntity<List<NotificationDTO>> getUserNotifications(
            @PathVariable String userId,
            @RequestParam(value = "read", required = false) Boolean read) {
        
        log.info("Fetching notifications for user: {}, read status: {}", userId, read);
        List<NotificationDTO> notifications = notificationService.getUserNotifications(userId, read);
        return ResponseEntity.ok(notifications);
    }

    @GetMapping("/count/{userId}")
    public ResponseEntity<NotificationCountDTO> getNotificationCount(@PathVariable String userId) {
        log.info("Fetching notification count for user: {}", userId);
        NotificationCountDTO count = notificationService.getNotificationCount(userId);
        return ResponseEntity.ok(count);
    }

    @GetMapping("/{id}")
    public ResponseEntity<NotificationDTO> getNotificationById(@PathVariable Long id) {
        log.info("Fetching notification with ID: {}", id);
        NotificationDTO notification = notificationService.getNotificationById(id);
        return ResponseEntity.ok(notification);
    }

    @PostMapping
    public ResponseEntity<NotificationDTO> createNotification(@Valid @RequestBody NotificationCreateDTO notificationDto) {
        log.info("Creating notification for user: {}", notificationDto.getUserId());
        NotificationDTO createdNotification = notificationService.createNotification(notificationDto);
        
        if (createdNotification == null) {
            return ResponseEntity.noContent().build();
        }
        
        return ResponseEntity.ok(createdNotification);
    }

    @PutMapping("/{id}/read")
    public ResponseEntity<NotificationDTO> markAsRead(@PathVariable Long id) {
        log.info("Marking notification as read: {}", id);
        NotificationDTO updatedNotification = notificationService.markAsRead(id);
        return ResponseEntity.ok(updatedNotification);
    }

    @PutMapping("/user/{userId}/read-all")
    public ResponseEntity<Void> markAllAsRead(@PathVariable String userId) {
        log.info("Marking all notifications as read for user: {}", userId);
        notificationService.markAllAsRead(userId);
        return ResponseEntity.ok().build();
    }

    @PostMapping("/email")
    public ResponseEntity<Void> sendEmail(
            @RequestParam String to,
            @RequestParam String subject,
            @RequestParam String content) {
        
        log.info("Sending email to: {}, subject: {}", to, subject);
        notificationService.sendEmail(to, subject, content);
        return ResponseEntity.ok().build();
    }

    @PostMapping("/email/template")
    public ResponseEntity<Void> sendTemplatedEmail(
            @RequestParam String to,
            @RequestParam String templateCode,
            @RequestBody Map<String, Object> data) {
        
        log.info("Sending templated email to: {}, template: {}", to, templateCode);
        notificationService.sendTemplatedEmail(to, templateCode, data);
        return ResponseEntity.ok().build();
    }
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\controller\NotificationPreferenceController.java ===
package com.recruitpme.notificationservice.controller;

import com.recruitpme.notificationservice.dto.NotificationPreferenceDTO;
import com.recruitpme.notificationservice.service.NotificationPreferenceService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;


@RestController
@RequestMapping("/api/notification-preferences")
@RequiredArgsConstructor
@Slf4j
public class NotificationPreferenceController {

    private final NotificationPreferenceService preferenceService;

    @GetMapping("/{userId}")
    public ResponseEntity<NotificationPreferenceDTO> getUserPreferences(@PathVariable String userId) {
        log.info("Fetching notification preferences for user: {}", userId);
        NotificationPreferenceDTO preferences = preferenceService.getUserPreferences(userId);
        return ResponseEntity.ok(preferences);
    }

    @PutMapping("/{userId}")
    public ResponseEntity<NotificationPreferenceDTO> updateUserPreferences(
            @PathVariable String userId,
            @Valid @RequestBody NotificationPreferenceDTO preferencesDto) {
        
        log.info("Updating notification preferences for user: {}", userId);
        NotificationPreferenceDTO updatedPreferences = preferenceService.updateUserPreferences(userId, preferencesDto);
        return ResponseEntity.ok(updatedPreferences);
    }

    @PostMapping("/{userId}/reset")
    public ResponseEntity<NotificationPreferenceDTO> resetUserPreferences(@PathVariable String userId) {
        log.info("Resetting notification preferences for user: {}", userId);
        NotificationPreferenceDTO defaultPreferences = preferenceService.resetUserPreferences(userId);
        return ResponseEntity.ok(defaultPreferences);
    }
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\dto\EmailTemplateDTO.java ===
package com.recruitpme.notificationservice.dto;

import lombok.Data;

import javax.validation.constraints.NotBlank;


@Data
public class EmailTemplateDTO {
    private Long id;
    
    @NotBlank(message = "Template code is required")
    private String code;
    
    @NotBlank(message = "Template name is required")
    private String name;
    
    @NotBlank(message = "Subject is required")
    private String subject;
    
    @NotBlank(message = "Content is required")
    private String content;
    
    private String description;
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\dto\NotificationCountDTO.java ===
package com.recruitpme.notificationservice.dto;

import lombok.Data;


@Data
public class NotificationCountDTO {
    private String userId;
    private long unreadCount;
    private long totalCount;
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\dto\NotificationCreateDTO.java ===
package com.recruitpme.notificationservice.dto;

import lombok.Data;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;


@Data
public class NotificationCreateDTO {
    
    @NotBlank(message = "User ID is required")
    private String userId;
    
    @NotBlank(message = "Notification type is required")
    private String type;
    
    @NotBlank(message = "Title is required")
    private String title;
    
    @NotBlank(message = "Message is required")
    private String message;
    
    private String link;
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\dto\NotificationDTO.java ===
package com.recruitpme.notificationservice.dto;

import lombok.Data;

import java.time.LocalDateTime;


@Data
public class NotificationDTO {
    private Long id;
    private String userId;
    private String type;
    private String title;
    private String message;
    private String link;
    private boolean read;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\dto\NotificationPreferenceDTO.java ===
package com.recruitpme.notificationservice.dto;

import lombok.Data;

import java.util.List;


@Data
public class NotificationPreferenceDTO {
    private Long id;
    private String userId;
    private boolean emailNotifications;
    private boolean inAppNotifications;
    private boolean smsNotifications;
    private List<String> disabledCategories;
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\entity\EmailTemplate.java ===
package com.recruitpme.notificationservice.entity;

import lombok.Data;

import javax.persistence.*;


@Entity
@Table(name = "email_templates")
@Data
public class EmailTemplate {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true)
    private String code;
    
    private String name;
    
    private String subject;
    
    @Column(columnDefinition = "TEXT")
    private String content;
    
    @Column(columnDefinition = "TEXT")
    private String description;
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\entity\Notification.java ===
package com.recruitpme.notificationservice.entity;

import lombok.Data;

import javax.persistence.*;
import java.time.LocalDateTime;


@Entity
@Table(name = "notifications")
@Data
public class Notification {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String userId;
    
    private String type; // EMAIL, IN_APP, SMS
    
    private String title;
    
    @Column(columnDefinition = "TEXT")
    private String message;
    
    private String link;
    
    private boolean read;
    
    private LocalDateTime createdAt;
    
    private LocalDateTime updatedAt;
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\entity\NotificationPreference.java ===
package com.recruitpme.notificationservice.entity;

import lombok.Data;

import javax.persistence.*;


@Entity
@Table(name = "notification_preferences")
@Data
public class NotificationPreference {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String userId;
    
    private boolean emailNotifications;
    
    private boolean inAppNotifications;
    
    private boolean smsNotifications;
    
    @Column(columnDefinition = "TEXT")
    private String disabledCategories; // comma separated
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\exception\GlobalExceptionHandler.java ===
package com.recruitpme.notificationservice.exception;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;


import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Map<String, String>> handleResourceNotFoundException(ResourceNotFoundException ex) {
        log.error("Resource not found exception: {}", ex.getMessage());
        
        Map<String, String> response = new HashMap<>();
        response.put("message", ex.getMessage());
        response.put("status", "NOT_FOUND");
        
        return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, Object>> handleValidationExceptions(MethodArgumentNotValidException ex) {
        log.error("Validation exception: {}", ex.getMessage());
        
        Map<String, Object> response = new HashMap<>();
        Map<String, String> errors = new HashMap<>();
        
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        
        response.put("message", "Validation failed");
        response.put("status", "BAD_REQUEST");
        response.put("errors", errors);
        
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }
    
    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<Map<String, String>> handleIllegalStateException(IllegalStateException ex) {
        log.error("Illegal state exception: {}", ex.getMessage());
        
        Map<String, String> response = new HashMap<>();
        response.put("message", ex.getMessage());
        response.put("status", "BAD_REQUEST");
        
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, String>> handleGlobalException(Exception ex) {
        log.error("Unexpected exception: {}", ex.getMessage(), ex);
        
        Map<String, String> response = new HashMap<>();
        response.put("message", "An unexpected error occurred");
        response.put("status", "INTERNAL_SERVER_ERROR");
        
        return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\exception\ResourceNotFoundException.java ===
package com.recruitpme.notificationservice.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;


@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\repository\EmailTemplateRepository.java ===
package com.recruitpme.notificationservice.repository;

import com.recruitpme.notificationservice.entity.EmailTemplate;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;


@Repository
public interface EmailTemplateRepository extends JpaRepository<EmailTemplate, Long> {
    
    Optional<EmailTemplate> findByCode(String code);
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\repository\NotificationPreferenceRepository.java ===
package com.recruitpme.notificationservice.repository;

import com.recruitpme.notificationservice.entity.NotificationPreference;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;


@Repository
public interface NotificationPreferenceRepository extends JpaRepository<NotificationPreference, Long> {
    
    Optional<NotificationPreference> findByUserId(String userId);
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\repository\NotificationRepository.java ===
package com.recruitpme.notificationservice.repository;

import com.recruitpme.notificationservice.entity.Notification;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;


@Repository
public interface NotificationRepository extends JpaRepository<Notification, Long> {
    
    List<Notification> findByUserIdOrderByCreatedAtDesc(String userId);
    
    List<Notification> findByUserIdAndReadOrderByCreatedAtDesc(String userId, boolean read);
    
    long countByUserIdAndRead(String userId, boolean read);
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\service\EmailTemplateService.java ===
package com.recruitpme.notificationservice.service;

import com.recruitpme.notificationservice.dto.EmailTemplateDTO;

import java.util.List;


public interface EmailTemplateService {
    
    List<EmailTemplateDTO> getAllTemplates();
    
    EmailTemplateDTO getTemplateById(Long id);
    
    EmailTemplateDTO getTemplateByCode(String code);
    
    EmailTemplateDTO createTemplate(EmailTemplateDTO templateDto);
    
    EmailTemplateDTO updateTemplate(Long id, EmailTemplateDTO templateDto);
    
    void deleteTemplate(Long id);
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\service\EmailTemplateServiceImpl.java ===
package com.recruitpme.notificationservice.service;

import com.recruitpme.notificationservice.dto.EmailTemplateDTO;
import com.recruitpme.notificationservice.entity.EmailTemplate;
import com.recruitpme.notificationservice.exception.ResourceNotFoundException;
import com.recruitpme.notificationservice.repository.EmailTemplateRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;


import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class EmailTemplateServiceImpl implements EmailTemplateService {

    private final EmailTemplateRepository emailTemplateRepository;

    @Override
    @Transactional(readOnly = true)
    public List<EmailTemplateDTO> getAllTemplates() {
        List<EmailTemplate> templates = emailTemplateRepository.findAll();
        
        return templates.stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public EmailTemplateDTO getTemplateById(Long id) {
        EmailTemplate template = emailTemplateRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Email template not found with id: " + id));
        
        return convertToDTO(template);
    }

    @Override
    @Transactional(readOnly = true)
    public EmailTemplateDTO getTemplateByCode(String code) {
        EmailTemplate template = emailTemplateRepository.findByCode(code)
                .orElseThrow(() -> new ResourceNotFoundException("Email template not found with code: " + code));
        
        return convertToDTO(template);
    }

    @Override
    @Transactional
    public EmailTemplateDTO createTemplate(EmailTemplateDTO templateDto) {
        // Check if template with same code already exists
        if (emailTemplateRepository.findByCode(templateDto.getCode()).isPresent()) {
            throw new IllegalStateException("Email template with code " + templateDto.getCode() + " already exists");
        }
        
        EmailTemplate template = new EmailTemplate();
        template.setCode(templateDto.getCode());
        template.setName(templateDto.getName());
        template.setSubject(templateDto.getSubject());
        template.setContent(templateDto.getContent());
        template.setDescription(templateDto.getDescription());
        
        EmailTemplate savedTemplate = emailTemplateRepository.save(template);
        
        return convertToDTO(savedTemplate);
    }

    @Override
    @Transactional
    public EmailTemplateDTO updateTemplate(Long id, EmailTemplateDTO templateDto) {
        EmailTemplate template = emailTemplateRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Email template not found with id: " + id));
        
        // Check if code is being changed and if new code already exists
        if (!template.getCode().equals(templateDto.getCode()) && 
            emailTemplateRepository.findByCode(templateDto.getCode()).isPresent()) {
            throw new IllegalStateException("Email template with code " + templateDto.getCode() + " already exists");
        }
        
        template.setCode(templateDto.getCode());
        template.setName(templateDto.getName());
        template.setSubject(templateDto.getSubject());
        template.setContent(templateDto.getContent());
        template.setDescription(templateDto.getDescription());
        
        EmailTemplate updatedTemplate = emailTemplateRepository.save(template);
        
        return convertToDTO(updatedTemplate);
    }

    @Override
    @Transactional
    public void deleteTemplate(Long id) {
        if (!emailTemplateRepository.existsById(id)) {
            throw new ResourceNotFoundException("Email template not found with id: " + id);
        }
        
        emailTemplateRepository.deleteById(id);
    }
    
    private EmailTemplateDTO convertToDTO(EmailTemplate template) {
        EmailTemplateDTO dto = new EmailTemplateDTO();
        dto.setId(template.getId());
        dto.setCode(template.getCode());
        dto.setName(template.getName());
        dto.setSubject(template.getSubject());
        dto.setContent(template.getContent());
        dto.setDescription(template.getDescription());
        
        return dto;
    }
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\service\NotificationPreferenceService.java ===
package com.recruitpme.notificationservice.service;

import com.recruitpme.notificationservice.dto.NotificationPreferenceDTO;


public interface NotificationPreferenceService {
    
    NotificationPreferenceDTO getUserPreferences(String userId);
    
    NotificationPreferenceDTO updateUserPreferences(String userId, NotificationPreferenceDTO preferencesDto);
    
    NotificationPreferenceDTO resetUserPreferences(String userId);
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\service\NotificationPreferenceServiceImpl.java ===
package com.recruitpme.notificationservice.service;

import com.recruitpme.notificationservice.dto.NotificationPreferenceDTO;
import com.recruitpme.notificationservice.entity.NotificationPreference;
import com.recruitpme.notificationservice.repository.NotificationPreferenceRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;


import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationPreferenceServiceImpl implements NotificationPreferenceService {

    private final NotificationPreferenceRepository preferenceRepository;

    @Override
    @Transactional(readOnly = true)
    public NotificationPreferenceDTO getUserPreferences(String userId) {
        Optional<NotificationPreference> preferenceOpt = preferenceRepository.findByUserId(userId);
        
        // If user has no preferences yet, create default ones
        if (preferenceOpt.isEmpty()) {
            return createDefaultPreferences(userId);
        }
        
        return convertToDTO(preferenceOpt.get());
    }

    @Override
    @Transactional
    public NotificationPreferenceDTO updateUserPreferences(String userId, NotificationPreferenceDTO preferencesDto) {
        Optional<NotificationPreference> preferenceOpt = preferenceRepository.findByUserId(userId);
        
        NotificationPreference preference;
        
        if (preferenceOpt.isEmpty()) {
            // Create new preferences if none exist
            preference = new NotificationPreference();
            preference.setUserId(userId);
        } else {
            preference = preferenceOpt.get();
        }
        
        preference.setEmailNotifications(preferencesDto.isEmailNotifications());
        preference.setInAppNotifications(preferencesDto.isInAppNotifications());
        preference.setSmsNotifications(preferencesDto.isSmsNotifications());
        
        // Convert disabled categories list to comma-separated string
        if (preferencesDto.getDisabledCategories() != null && !preferencesDto.getDisabledCategories().isEmpty()) {
            preference.setDisabledCategories(String.join(",", preferencesDto.getDisabledCategories()));
        } else {
            preference.setDisabledCategories("");
        }
        
        NotificationPreference savedPreference = preferenceRepository.save(preference);
        
        return convertToDTO(savedPreference);
    }

    @Override
    @Transactional
    public NotificationPreferenceDTO resetUserPreferences(String userId) {
        Optional<NotificationPreference> preferenceOpt = preferenceRepository.findByUserId(userId);
        
        if (preferenceOpt.isPresent()) {
            preferenceRepository.delete(preferenceOpt.get());
        }
        
        return createDefaultPreferences(userId);
    }
    
    private NotificationPreferenceDTO createDefaultPreferences(String userId) {
        NotificationPreference preference = new NotificationPreference();
        preference.setUserId(userId);
        preference.setEmailNotifications(true);
        preference.setInAppNotifications(true);
        preference.setSmsNotifications(false);
        preference.setDisabledCategories("");
        
        NotificationPreference savedPreference = preferenceRepository.save(preference);
        
        return convertToDTO(savedPreference);
    }
    
    private NotificationPreferenceDTO convertToDTO(NotificationPreference preference) {
        NotificationPreferenceDTO dto = new NotificationPreferenceDTO();
        dto.setId(preference.getId());
        dto.setUserId(preference.getUserId());
        dto.setEmailNotifications(preference.isEmailNotifications());
        dto.setInAppNotifications(preference.isInAppNotifications());
        dto.setSmsNotifications(preference.isSmsNotifications());
        
        // Convert comma-separated string to list
        if (preference.getDisabledCategories() != null && !preference.getDisabledCategories().isEmpty()) {
            dto.setDisabledCategories(Arrays.asList(preference.getDisabledCategories().split(",")));
        }
        
        return dto;
    }
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\service\NotificationService.java ===
package com.recruitpme.notificationservice.service;

import com.recruitpme.notificationservice.dto.NotificationCountDTO;
import com.recruitpme.notificationservice.dto.NotificationCreateDTO;
import com.recruitpme.notificationservice.dto.NotificationDTO;


import java.util.List;

public interface NotificationService {
    
    List<NotificationDTO> getUserNotifications(String userId, Boolean read);
    
    NotificationDTO getNotificationById(Long id);
    
    NotificationDTO createNotification(NotificationCreateDTO notificationDto);
    
    NotificationDTO markAsRead(Long id);
    
    void markAllAsRead(String userId);
    
    NotificationCountDTO getNotificationCount(String userId);
    
    void sendEmail(String to, String subject, String content);
    
    void sendTemplatedEmail(String to, String templateCode, Object data);
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\java\com\recruitpme\notificationservice\service\NotificationServiceImpl.java ===
package com.recruitpme.notificationservice.service;


import com.recruitpme.notificationservice.dto.NotificationCountDTO;
import com.recruitpme.notificationservice.dto.NotificationCreateDTO;
import com.recruitpme.notificationservice.dto.NotificationDTO;
import com.recruitpme.notificationservice.entity.EmailTemplate;
import com.recruitpme.notificationservice.entity.Notification;
import com.recruitpme.notificationservice.entity.NotificationPreference;
import com.recruitpme.notificationservice.exception.ResourceNotFoundException;
import com.recruitpme.notificationservice.repository.EmailTemplateRepository;
import com.recruitpme.notificationservice.repository.NotificationPreferenceRepository;
import com.recruitpme.notificationservice.repository.NotificationRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.thymeleaf.context.Context;
import org.thymeleaf.spring5.SpringTemplateEngine;

import javax.mail.MessagingException;
import javax.mail.internet.MimeMessage;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationServiceImpl implements NotificationService {

    private final NotificationRepository notificationRepository;
    private final NotificationPreferenceRepository preferenceRepository;
    private final EmailTemplateRepository emailTemplateRepository;
    private final JavaMailSender emailSender;
    private final SpringTemplateEngine templateEngine;
    
    private final String fromEmail;

    @Override
    @Transactional(readOnly = true)
    public List<NotificationDTO> getUserNotifications(String userId, Boolean read) {
        List<Notification> notifications;
        
        if (read != null) {
            notifications = notificationRepository.findByUserIdAndReadOrderByCreatedAtDesc(userId, read);
        } else {
            notifications = notificationRepository.findByUserIdOrderByCreatedAtDesc(userId);
        }
        
        return notifications.stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public NotificationDTO getNotificationById(Long id) {
        Notification notification = notificationRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Notification not found with id: " + id));
        
        return convertToDTO(notification);
    }

    @Override
    @Transactional
    public NotificationDTO createNotification(NotificationCreateDTO notificationDto) {
        // Check user notification preferences
        Optional<NotificationPreference> preferenceOpt = preferenceRepository.findByUserId(notificationDto.getUserId());
        
        // If user has disabled this type of notification, log and return null
        if (preferenceOpt.isPresent()) {
            NotificationPreference preference = preferenceOpt.get();
            
            if ("EMAIL".equals(notificationDto.getType()) && !preference.isEmailNotifications() ||
                "IN_APP".equals(notificationDto.getType()) && !preference.isInAppNotifications() ||
                "SMS".equals(notificationDto.getType()) && !preference.isSmsNotifications()) {
                
                log.info("User {} has disabled {} notifications", notificationDto.getUserId(), notificationDto.getType());
                return null;
            }
            
            // Check if category is disabled
            if (preference.getDisabledCategories() != null && !preference.getDisabledCategories().isEmpty()) {
                String[] disabledCategories = preference.getDisabledCategories().split(",");
                for (String category : disabledCategories) {
                    if (notificationDto.getTitle().toLowerCase().contains(category.toLowerCase())) {
                        log.info("User {} has disabled notifications for category {}", notificationDto.getUserId(), category);
                        return null;
                    }
                }
            }
        }
        
        Notification notification = new Notification();
        notification.setUserId(notificationDto.getUserId());
        notification.setType(notificationDto.getType());
        notification.setTitle(notificationDto.getTitle());
        notification.setMessage(notificationDto.getMessage());
        notification.setLink(notificationDto.getLink());
        notification.setRead(false);
        notification.setCreatedAt(LocalDateTime.now());
        
        Notification savedNotification = notificationRepository.save(notification);
        
        return convertToDTO(savedNotification);
    }

    @Override
    @Transactional
    public NotificationDTO markAsRead(Long id) {
        Notification notification = notificationRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Notification not found with id: " + id));
        
        notification.setRead(true);
        notification.setUpdatedAt(LocalDateTime.now());
        
        Notification updatedNotification = notificationRepository.save(notification);
        
        return convertToDTO(updatedNotification);
    }

    @Override
    @Transactional
    public void markAllAsRead(String userId) {
        List<Notification> unreadNotifications = notificationRepository.findByUserIdAndReadOrderByCreatedAtDesc(userId, false);
        
        unreadNotifications.forEach(notification -> {
            notification.setRead(true);
            notification.setUpdatedAt(LocalDateTime.now());
        });
        
        notificationRepository.saveAll(unreadNotifications);
    }

    @Override
    @Transactional(readOnly = true)
    public NotificationCountDTO getNotificationCount(String userId) {
        long unreadCount = notificationRepository.countByUserIdAndRead(userId, false);
        long totalCount = notificationRepository.countByUserIdAndRead(userId, true) + unreadCount;
        
        NotificationCountDTO countDTO = new NotificationCountDTO();
        countDTO.setUserId(userId);
        countDTO.setUnreadCount(unreadCount);
        countDTO.setTotalCount(totalCount);
        
        return countDTO;
    }

    @Override
    public void sendEmail(String to, String subject, String content) {
        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setFrom(fromEmail);
            message.setTo(to);
            message.setSubject(subject);
            message.setText(content);
            
            emailSender.send(message);
            
            log.info("Email sent successfully to: {}", to);
        } catch (Exception e) {
            log.error("Failed to send email to: {}, error: {}", to, e.getMessage());
            throw new RuntimeException("Failed to send email", e);
        }
    }

    @Override
    public void sendTemplatedEmail(String to, String templateCode, Object data) {
        try {
            // Get email template
            EmailTemplate template = emailTemplateRepository.findByCode(templateCode)
                    .orElseThrow(() -> new ResourceNotFoundException("Email template not found with code: " + templateCode));
            
            // Prepare message
            MimeMessage message = emailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");
            
            helper.setFrom(fromEmail);
            helper.setTo(to);
            helper.setSubject(template.getSubject());
            
            // Process template with Thymeleaf
            Context context = new Context();
            
            // If data is a map, add all entries to context
            if (data instanceof Map) {
                Map<String, Object> dataMap = (Map<String, Object>) data;
                dataMap.forEach(context::setVariable);
            } else {
                // If not a map, add data as a single variable
                context.setVariable("data", data);
            }
            
            String htmlContent = templateEngine.process(templateCode, context);
            helper.setText(htmlContent, true);
            
            emailSender.send(message);
            
            log.info("Templated email sent successfully to: {}, template: {}", to, templateCode);
        } catch (MessagingException e) {
            log.error("Failed to send templated email to: {}, template: {}, error: {}", to, templateCode, e.getMessage());
            throw new RuntimeException("Failed to send templated email", e);
        }
    }
    
    private NotificationDTO convertToDTO(Notification notification) {
        NotificationDTO dto = new NotificationDTO();
        dto.setId(notification.getId());
        dto.setUserId(notification.getUserId());
        dto.setType(notification.getType());
        dto.setTitle(notification.getTitle());
        dto.setMessage(notification.getMessage());
        dto.setLink(notification.getLink());
        dto.setRead(notification.isRead());
        dto.setCreatedAt(notification.getCreatedAt());
        dto.setUpdatedAt(notification.getUpdatedAt());
        
        return dto;
    }
}
=== FIN ===

=== Contenu de backend\notification-service\src\main\resources\application.properties ===
# Server configuration
server.port=8085
spring.application.name=notification-service

# Database configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/notification_db
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.datasource.driver-class-name=org.postgresql.Driver


# JPA configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# Email configuration
mail.host=smtp.gmail.com
mail.port=587
mail.username=your-email@gmail.com
mail.password=your-email-password

# Redis for notification caching
spring.redis.host=redis
spring.redis.port=6379

# Logging
logging.level.com.recruitpme.notificationservice=DEBUG
=== FIN ===

=== Contenu de backend\notification-service\src\main\resources\templates\mail\welcome.html ===
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    
    <title>Welcome to RecrutPME</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            background-color: #4A6FDC;
            color: white;
            padding: 20px;
            text-align: center;
        }
        .content {
            padding: 20px;
            background-color: #f8f9fa;
        }
        .footer {
            text-align: center;
            padding: 10px;
            font-size: 12px;
            color: #777;
        }
        .button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #4A6FDC;
            color: white;
            text-decoration: none;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Bienvenue sur RecrutPME</h1>
        </div>
        <div class="content">
            <p>Bonjour <span th:text="${firstName}">prénom</span>,</p>
            
            <p>Nous sommes ravis de vous accueillir sur RecrutPME, votre nouvelle plateforme d'analyse de CV par intelligence artificielle.</p>
            
            <p>Avec RecrutPME, vous pouvez :</p>
            <ul>
                <li>Analyser des CV automatiquement</li>
                <li>Identifier les meilleurs candidats pour vos postes</li>
                <li>Gagner du temps dans votre processus de recrutement</li>
                <li>Suivre les candidats tout au long du processus</li>
            </ul>
            
            <p>Pour commencer, connectez-vous à votre compte :</p>
            
            <p style="text-align: center;">
                <a th:href="${loginUrl}" class="button">Se connecter à RecrutPME</a>
            </p>
            
            <p>Si vous avez des questions, n'hésitez pas à nous contacter.</p>
            
            <p>Cordialement,<br>
            L'équipe RecrutPME</p>
        </div>
        <div class="footer">
            <p>© 2025 RecrutPME. Tous droits réservés.</p>
        </div>
    </div>
</body>
</html>
=== FIN ===

=== Contenu de backend\user-service\Dockerfile ===
FROM eclipse-temurin:17-jre
WORKDIR /app

COPY target/*.jar app.jar

EXPOSE 8086
ENTRYPOINT ["java", "-jar", "app.jar"]

=== FIN ===


=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\UserServiceApplication.java ===
package com.recruitpme.userservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;


@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients
public class UserServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\client\NotificationServiceClient.java ===
package com.recruitpme.userservice.client;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;


import java.util.Map;

@FeignClient(name = "notification-service", url = "${services.notification-service.url}")
public interface NotificationServiceClient {

    @PostMapping("/api/notifications/email")
    void sendEmail(
            @RequestParam("to") String to,
            @RequestParam("subject") String subject,
            @RequestParam("content") String content);
    
    @PostMapping("/api/notifications/email/template")
    void sendTemplatedEmail(
            @RequestParam("to") String to,
            @RequestParam("templateCode") String templateCode,
            Map<String, Object> data);
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\config\FeignConfig.java ===
package com.recruitpme.userservice.config;

import feign.RequestInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;


@Configuration
public class FeignConfig {

    @Bean
    public RequestInterceptor requestInterceptor() {
        return requestTemplate -> {
            ServletRequestAttributes attrs = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
            if (attrs != null) {
                String authHeader = attrs.getRequest().getHeader("Authorization");
                if (authHeader != null) {
                    requestTemplate.header("Authorization", authHeader);
                }
            }
        };
    }
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\config\RedisConfig.java ===
package com.recruitpme.userservice.config;

import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext.SerializationPair;


import java.time.Duration;

@Configuration
@EnableCaching
public class RedisConfig {

    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration cacheConfig = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10))
                .serializeValuesWith(SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));
        
        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(cacheConfig)
                .build();
    }
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\config\SecurityConfig.java ===
package com.recruitpme.userservice.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;


@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .cors().and()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()
            .authorizeRequests()
            .antMatchers("/api/**").permitAll()  // Since authentication is handled by API Gateway
            .anyRequest().authenticated();
        
        return http.build();
    }
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\controller\UserController.java ===
package com.recruitpme.userservice.controller;

import com.recruitpme.userservice.dto.UserCreateDTO;
import com.recruitpme.userservice.dto.UserDTO;
import com.recruitpme.userservice.dto.UserUpdateDTO;
import com.recruitpme.userservice.service.UserService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;


import javax.validation.Valid;
import java.util.List;

@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
@Slf4j
public class UserController {

    private final UserService userService;

    @GetMapping
    public ResponseEntity<List<UserDTO>> getAllUsers() {
        log.info("Fetching all users");
        List<UserDTO> users = userService.getAllUsers();
        return ResponseEntity.ok(users);
    }

    @GetMapping("/paginated")
    public ResponseEntity<Page<UserDTO>> getUsersPaginated(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        
        log.info("Fetching paginated users with page: {} and size: {}", page, size);
        Page<UserDTO> users = userService.getUsersPaginated(page, size);
        return ResponseEntity.ok(users);
    }

    @GetMapping("/search")
    public ResponseEntity<Page<UserDTO>> searchUsers(
            @RequestParam String keyword,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        
        log.info("Searching users with keyword: {}, page: {}, size: {}", keyword, page, size);
        Page<UserDTO> users = userService.searchUsers(keyword, page, size);
        return ResponseEntity.ok(users);
    }

    @GetMapping("/{id}")
    public ResponseEntity<UserDTO> getUserById(@PathVariable Long id) {
        log.info("Fetching user with ID: {}", id);
        UserDTO user = userService.getUserById(id);
        return ResponseEntity.ok(user);
    }

    @GetMapping("/email/{email}")
    public ResponseEntity<UserDTO> getUserByEmail(@PathVariable String email) {
        log.info("Fetching user with email: {}", email);
        UserDTO user = userService.getUserByEmail(email);
        return ResponseEntity.ok(user);
    }

    @PostMapping
    public ResponseEntity<UserDTO> createUser(@Valid @RequestBody UserCreateDTO userDto) {
        log.info("Creating user with email: {}", userDto.getEmail());
        UserDTO createdUser = userService.createUser(userDto);
        return ResponseEntity.ok(createdUser);
    }

    @PutMapping("/{id}")
    public ResponseEntity<UserDTO> updateUser(
            @PathVariable Long id,
            @Valid @RequestBody UserUpdateDTO userDto) {
        
        log.info("Updating user with ID: {}", id);
        UserDTO updatedUser = userService.updateUser(id, userDto);
        return ResponseEntity.ok(updatedUser);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        log.info("Deleting user with ID: {}", id);
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\controller\UserPreferenceController.java ===
package com.recruitpme.userservice.controller;

import com.recruitpme.userservice.dto.UserPreferenceDTO;
import com.recruitpme.userservice.service.UserPreferenceService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;


import javax.validation.Valid;

@RestController
@RequestMapping("/api/users/{userId}/preferences")
@RequiredArgsConstructor
@Slf4j
public class UserPreferenceController {

    private final UserPreferenceService userPreferenceService;

    @GetMapping
    public ResponseEntity<UserPreferenceDTO> getUserPreferences(@PathVariable Long userId) {
        log.info("Fetching preferences for user with ID: {}", userId);
        UserPreferenceDTO preferences = userPreferenceService.getUserPreferences(userId);
        return ResponseEntity.ok(preferences);
    }

    @PutMapping
    public ResponseEntity<UserPreferenceDTO> updateUserPreferences(
            @PathVariable Long userId,
            @Valid @RequestBody UserPreferenceDTO preferencesDto) {
        
        log.info("Updating preferences for user with ID: {}", userId);
        UserPreferenceDTO updatedPreferences = userPreferenceService.updateUserPreferences(userId, preferencesDto);
        return ResponseEntity.ok(updatedPreferences);
    }

    @PostMapping("/reset")
    public ResponseEntity<UserPreferenceDTO> resetUserPreferences(@PathVariable Long userId) {
        log.info("Resetting preferences for user with ID: {}", userId);
        UserPreferenceDTO defaultPreferences = userPreferenceService.resetUserPreferences(userId);
        return ResponseEntity.ok(defaultPreferences);
    }
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\dto\UserCreateDTO.java ===
package com.recruitpme.userservice.dto;

import lombok.Data;

import javax.validation.constraints.Email;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Size;


@Data
public class UserCreateDTO {
    
    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    private String email;
    
    @NotBlank(message = "First name is required")
    private String firstName;
    
    @NotBlank(message = "Last name is required")
    private String lastName;
    
    private String companyName;
    
    private String phoneNumber;
    
    @NotBlank(message = "Role is required")
    private String role;
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\dto\UserDTO.java ===
package com.recruitpme.userservice.dto;

import lombok.Data;

import java.time.LocalDateTime;


@Data
public class UserDTO {
    private Long id;
    private String email;
    private String firstName;
    private String lastName;
    private String companyName;
    private String phoneNumber;
    private String role;
    private boolean enabled;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\dto\UserPreferenceDTO.java ===
package com.recruitpme.userservice.dto;

import lombok.Data;


@Data
public class UserPreferenceDTO {
    private Long id;
    private Long userId;
    private String language;
    private String timezone;
    private String theme;
    private String dashboardLayout;
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\dto\UserUpdateDTO.java ===
package com.recruitpme.userservice.dto;

import lombok.Data;

import javax.validation.constraints.Email;


@Data
public class UserUpdateDTO {
    
    @Email(message = "Email should be valid")
    private String email;
    
    private String firstName;
    
    private String lastName;
    
    private String companyName;
    
    private String phoneNumber;
    
    private String role;
    
    private Boolean enabled;
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\entity\User.java ===
package com.recruitpme.userservice.entity;

import lombok.Data;

import javax.persistence.*;
import java.time.LocalDateTime;


@Entity
@Table(name = "users")
@Data
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false)
    private String email;
    
    private String firstName;
    
    private String lastName;
    
    private String companyName;
    
    private String phoneNumber;
    
    private String role;
    
    private boolean enabled;
    
    private LocalDateTime createdAt;
    
    private LocalDateTime updatedAt;
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\entity\UserPreference.java ===
package com.recruitpme.userservice.entity;

import lombok.Data;

import javax.persistence.*;


@Entity
@Table(name = "user_preferences")
@Data
public class UserPreference {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @OneToOne
    @JoinColumn(name = "user_id")
    private User user;
    
    private String language;
    
    private String timezone;
    
    private String theme; // light, dark
    
    @Column(columnDefinition = "TEXT")
    private String dashboardLayout; // JSON format
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\exception\GlobalExceptionHandler.java ===
package com.recruitpme.userservice.exception;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;


import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Map<String, String>> handleResourceNotFoundException(ResourceNotFoundException ex) {
        log.error("Resource not found exception: {}", ex.getMessage());
        
        Map<String, String> response = new HashMap<>();
        response.put("message", ex.getMessage());
        response.put("status", "NOT_FOUND");
        
        return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
    }
    
    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<Map<String, String>> handleIllegalStateException(IllegalStateException ex) {
        log.error("Illegal state exception: {}", ex.getMessage());
        
        Map<String, String> response = new HashMap<>();
        response.put("message", ex.getMessage());
        response.put("status", "BAD_REQUEST");
        
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, Object>> handleValidationExceptions(MethodArgumentNotValidException ex) {
        log.error("Validation exception: {}", ex.getMessage());
        
        Map<String, Object> response = new HashMap<>();
        Map<String, String> errors = new HashMap<>();
        
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        
        response.put("message", "Validation failed");
        response.put("status", "BAD_REQUEST");
        response.put("errors", errors);
        
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, String>> handleGlobalException(Exception ex) {
        log.error("Unexpected exception: {}", ex.getMessage(), ex);
        
        Map<String, String> response = new HashMap<>();
        response.put("message", "An unexpected error occurred");
        response.put("status", "INTERNAL_SERVER_ERROR");
        
        return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\exception\ResourceNotFoundException.java ===
package com.recruitpme.userservice.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;


@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\repository\UserPreferenceRepository.java ===
package com.recruitpme.userservice.repository;

import com.recruitpme.userservice.entity.UserPreference;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;


@Repository
public interface UserPreferenceRepository extends JpaRepository<UserPreference, Long> {
    
    Optional<UserPreference> findByUserId(Long userId);
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\repository\UserRepository.java ===
package com.recruitpme.userservice.repository;

import com.recruitpme.userservice.entity.User;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;


import java.util.List;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    Optional<User> findByEmail(String email);
    
    boolean existsByEmail(String email);
    
    List<User> findByEnabledTrue();
    
    Page<User> findByEnabledTrue(Pageable pageable);
    
    @Query("SELECT u FROM User u WHERE (:keyword IS NULL OR LOWER(u.firstName) LIKE LOWER(CONCAT('%', :keyword, '%')) OR LOWER(u.lastName) LIKE LOWER(CONCAT('%', :keyword, '%')) OR LOWER(u.email) LIKE LOWER(CONCAT('%', :keyword, '%')))")
    Page<User> searchUsers(@Param("keyword") String keyword, Pageable pageable);
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\service\UserPreferenceService.java ===
package com.recruitpme.userservice.service;

import com.recruitpme.userservice.dto.UserPreferenceDTO;


public interface UserPreferenceService {
    
    UserPreferenceDTO getUserPreferences(Long userId);
    
    UserPreferenceDTO updateUserPreferences(Long userId, UserPreferenceDTO preferencesDto);
    
    UserPreferenceDTO resetUserPreferences(Long userId);
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\service\UserPreferenceServiceImpl.java ===
package com.recruitpme.userservice.service;

import com.recruitpme.userservice.dto.UserPreferenceDTO;
import com.recruitpme.userservice.entity.User;
import com.recruitpme.userservice.entity.UserPreference;
import com.recruitpme.userservice.exception.ResourceNotFoundException;
import com.recruitpme.userservice.repository.UserPreferenceRepository;
import com.recruitpme.userservice.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;


import java.util.Optional;

@Service
@RequiredArgsConstructor
@Slf4j
public class UserPreferenceServiceImpl implements UserPreferenceService {

    private final UserRepository userRepository;
    private final UserPreferenceRepository userPreferenceRepository;

    @Override
    @Transactional(readOnly = true)
    public UserPreferenceDTO getUserPreferences(Long userId) {
        // Check if user exists
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + userId));
        
        // Get preferences
        Optional<UserPreference> preferenceOpt = userPreferenceRepository.findByUserId(userId);
        
        // If no preferences exist, create default ones
        if (preferenceOpt.isEmpty()) {
            return createDefaultPreferences(user);
        }
        
        return convertToDTO(preferenceOpt.get());
    }

    @Override
    @Transactional
    public UserPreferenceDTO updateUserPreferences(Long userId, UserPreferenceDTO preferencesDto) {
        // Check if user exists
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + userId));
        
        // Get or create preferences
        UserPreference preference = userPreferenceRepository.findByUserId(userId)
                .orElse(new UserPreference());
        
        preference.setUser(user);
        
        if (preferencesDto.getLanguage() != null) {
            preference.setLanguage(preferencesDto.getLanguage());
        }
        
        if (preferencesDto.getTimezone() != null) {
            preference.setTimezone(preferencesDto.getTimezone());
        }
        
        if (preferencesDto.getTheme() != null) {
            preference.setTheme(preferencesDto.getTheme());
        }
        
        if (preferencesDto.getDashboardLayout() != null) {
            preference.setDashboardLayout(preferencesDto.getDashboardLayout());
        }
        
        UserPreference savedPreference = userPreferenceRepository.save(preference);
        
        return convertToDTO(savedPreference);
    }

    @Override
    @Transactional
    public UserPreferenceDTO resetUserPreferences(Long userId) {
        // Check if user exists
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + userId));
        
        // Delete existing preferences if they exist
        userPreferenceRepository.findByUserId(userId)
                .ifPresent(userPreferenceRepository::delete);
        
        // Create default preferences
        return createDefaultPreferences(user);
    }
    
    private UserPreferenceDTO createDefaultPreferences(User user) {
        UserPreference preference = new UserPreference();
        preference.setUser(user);
        preference.setLanguage("fr");
        preference.setTimezone("Europe/Paris");
        preference.setTheme("light");
        preference.setDashboardLayout("{\"layout\":\"default\"}");
        
        UserPreference savedPreference = userPreferenceRepository.save(preference);
        
        return convertToDTO(savedPreference);
    }
    
    private UserPreferenceDTO convertToDTO(UserPreference preference) {
        UserPreferenceDTO dto = new UserPreferenceDTO();
        dto.setId(preference.getId());
        dto.setUserId(preference.getUser().getId());
        dto.setLanguage(preference.getLanguage());
        dto.setTimezone(preference.getTimezone());
        dto.setTheme(preference.getTheme());
        dto.setDashboardLayout(preference.getDashboardLayout());
        
        return dto;
    }
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\service\UserService.java ===
package com.recruitpme.userservice.service;

import com.recruitpme.userservice.dto.UserCreateDTO;
import com.recruitpme.userservice.dto.UserDTO;
import com.recruitpme.userservice.dto.UserUpdateDTO;
import org.springframework.data.domain.Page;


import java.util.List;

public interface UserService {
    
    List<UserDTO> getAllUsers();
    
    Page<UserDTO> getUsersPaginated(int page, int size);
    
    Page<UserDTO> searchUsers(String keyword, int page, int size);
    
    UserDTO getUserById(Long id);
    
    UserDTO getUserByEmail(String email);
    
    UserDTO createUser(UserCreateDTO userDto);
    
    UserDTO updateUser(Long id, UserUpdateDTO userDto);
    
    void deleteUser(Long id);
}
=== FIN ===

=== Contenu de backend\user-service\src\main\java\com\recruitpme\userservice\service\UserServiceImpl.java ===
package com.recruitpme.userservice.service;

import com.recruitpme.userservice.dto.UserCreateDTO;
import com.recruitpme.userservice.dto.UserDTO;
import com.recruitpme.userservice.dto.UserUpdateDTO;
import com.recruitpme.userservice.entity.User;
import com.recruitpme.userservice.exception.ResourceNotFoundException;
import com.recruitpme.userservice.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;


@Service
@RequiredArgsConstructor
@Slf4j
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;

    @Override
    @Transactional(readOnly = true)
    public List<UserDTO> getAllUsers() {
        List<User> users = userRepository.findByEnabledTrue();
        
        return users.stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public Page<UserDTO> getUsersPaginated(int page, int size) {
        PageRequest pageRequest = PageRequest.of(page, size, Sort.by("createdAt").descending());
        Page<User> userPage = userRepository.findByEnabledTrue(pageRequest);
        
        return userPage.map(this::convertToDTO);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<UserDTO> searchUsers(String keyword, int page, int size) {
        PageRequest pageRequest = PageRequest.of(page, size, Sort.by("lastName").ascending());
        Page<User> userPage = userRepository.searchUsers(keyword, pageRequest);
        
        return userPage.map(this::convertToDTO);
    }

    @Override
    @Transactional(readOnly = true)
    public UserDTO getUserById(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + id));
        
        return convertToDTO(user);
    }

    @Override
    @Transactional(readOnly = true)
    public UserDTO getUserByEmail(String email) {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with email: " + email));
        
        return convertToDTO(user);
    }

    @Override
    @Transactional
    public UserDTO createUser(UserCreateDTO userDto) {
        // Check if email already exists
        if (userRepository.existsByEmail(userDto.getEmail())) {
            throw new IllegalStateException("Email already in use: " + userDto.getEmail());
        }
        
        User user = new User();
        user.setEmail(userDto.getEmail());
        user.setFirstName(userDto.getFirstName());
        user.setLastName(userDto.getLastName());
        user.setCompanyName(userDto.getCompanyName());
        user.setPhoneNumber(userDto.getPhoneNumber());
        user.setRole(userDto.getRole());
        user.setEnabled(true);
        user.setCreatedAt(LocalDateTime.now());
        
        User savedUser = userRepository.save(user);
        
        return convertToDTO(savedUser);
    }

    @Override
    @Transactional
    public UserDTO updateUser(Long id, UserUpdateDTO userDto) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + id));
        
        // Check if email is being changed and if it's already in use
        if (userDto.getEmail() != null && !user.getEmail().equals(userDto.getEmail()) && 
            userRepository.existsByEmail(userDto.getEmail())) {
            throw new IllegalStateException("Email already in use: " + userDto.getEmail());
        }
        
        if (userDto.getEmail() != null) {
            user.setEmail(userDto.getEmail());
        }
        
        if (userDto.getFirstName() != null) {
            user.setFirstName(userDto.getFirstName());
        }
        
        if (userDto.getLastName() != null) {
            user.setLastName(userDto.getLastName());
        }
        
        if (userDto.getCompanyName() != null) {
            user.setCompanyName(userDto.getCompanyName());
        }
        
        if (userDto.getPhoneNumber() != null) {
            user.setPhoneNumber(userDto.getPhoneNumber());
        }
        
        if (userDto.getRole() != null) {
            user.setRole(userDto.getRole());
        }
        
        if (userDto.getEnabled() != null) {
            user.setEnabled(userDto.getEnabled());
        }
        
        user.setUpdatedAt(LocalDateTime.now());
        
        User updatedUser = userRepository.save(user);
        
        return convertToDTO(updatedUser);
    }

    @Override
    @Transactional
    public void deleteUser(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + id));
        
        // Soft delete by disabling the user
        user.setEnabled(false);
        user.setUpdatedAt(LocalDateTime.now());
        
        userRepository.save(user);
    }
    
    private UserDTO convertToDTO(User user) {
        UserDTO dto = new UserDTO();
        dto.setId(user.getId());
        dto.setEmail(user.getEmail());
        dto.setFirstName(user.getFirstName());
        dto.setLastName(user.getLastName());
        dto.setCompanyName(user.getCompanyName());
        dto.setPhoneNumber(user.getPhoneNumber());
        dto.setRole(user.getRole());
        dto.setEnabled(user.isEnabled());
        dto.setCreatedAt(user.getCreatedAt());
        dto.setUpdatedAt(user.getUpdatedAt());
        
        return dto;
    }
}
=== FIN ===

=== Contenu de backend\user-service\src\main\resources\application.properties ===
# Server configuration
server.port=8086
spring.application.name=user-service

# Database configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/user_db
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.datasource.driver-class-name=org.postgresql.Driver


# JPA configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# Redis caching
spring.redis.host=redis
spring.redis.port=6379
spring.cache.type=redis
spring.cache.redis.time-to-live=3600000

# Logging
logging.level.com.recruitpme.userservice=DEBUG
=== FIN ===

